Conference deadlines:
- ISMM          Feb 8?
- DLS 2013      June 8, 2013
- VMIL 2013     ~August 2013
- CGO 2014      ~September 2013
- CC 2014       Oct 4, Oct 11 2013
- PLDI 2014     Nov 8, Nov 15 2013
- VEE 2014      ~November 2013

Internships: Nov-Dec 2014, after paper deadlines?
~3-4 months
Marc advises to remain near PhD work, best for CV
Approach Mozilla around early June, combine with trip?
Approach Facebook

List of possible contributions:
- Type tagging scheme
- Register allocation
- Lazy/incremental JIT
- Basic block versioning
- Interprocedural versioning
- Incremental inlining vs classical inlining
- Typed shapes and basic block versioning

------------------------------------------------------------------------------

TODO: check the Moz guy's shape slides, check notes
TODO: read some of Mozilla's shape code, srysly
TODO: think about shapes more
- want a guaranteed minimum object size
  - no need for a special ext table, can use objects as is with len, next ptr
- how complicated would they be to implement in a basic form?
  - switch to shape idx
- how much simplification could you get on object property accesses?
  - sketch it out
- can use shape pointers directly
  - shapes can keep list of referring blocks
- start writing D code for shapes
  - class ObjShape
- no more "make_map"

TODO: not missing global prop opt?
- observation: if read once, we know its not missing

FIXME: much regexp code executed during init, why?

TODO: tweak inlining heuristics
- don't inline in global functions, unless they have loops? ***
  - IRFunction.hasLoop?
  - this might be extra beneficial, big functions that run only once
- could also only inline in functions that have loops
  - and/or maybe be super extra aggressive there
- *must* inline object access and low level primitives in getprop
  - runtime primitives that are less than 3-4 blocks should always be inlined

FIXME: empty fun, ret undefined twice
- see 200m_calls
- second one is from ctor entry
  - entry stub doesn't know which function we're in
  - needs to assume frame size is initial
- should push locals in entry, pop in ret

------------------------------------------------------------------------------

Goal: March 31st, type prop working, satisfying perf for article
- Type prop should enable speed gains on bigger benchmarks

TODO: smaller version of toBool for inlining?

TODO: profile again, lots of interesting things to learn!

TODO: simple reg alloc
- Marc says stack mapping, 1 bit per value
  - value is on stack or in reg for that stack slot
- could also think about delayed writes
  - all output operands go into table, map to regs, spill when full
  - is this simpler than modelizing occupied regs
- KISS: if you write a value to the stack, should also write its type
  - write type tags on spilling
  - if out opnd is stack, write type tag
- Outline options in detail

TODO: eliminate is_i32 peephole
- let the type analysis and BBV take care of that

TODO: command-line option to record primitive call frequency
- display sorted count
- only way to know what's relevant to optimize
- not that hard to implement, call some host primitive with a pointer to the D string

TODO: try to optimize inlineCall
- inlinePass does not do liveness analysis, is slow on its own
- what are the slowest parts of it?

TODO: try to optimize liveness analysis
- record total time taken in stats

Meeting:
- Fixed codegen bugs outlined at last group meeting
  - suboptimal direct jump
- Completed wider type tags refactoring
  - Fixed bugs, added more tests
- Added back stats for number of block versions
- Began smaller primitives for inlining
  - getPropField, getPropMethod, getPropElem, getPropLength
  - addInt (++), addIntFloat
  - ltIntFloat
  - fallback to old, complete primitives
- 3d-raytrace
  - primitive calls: 16.6M to 1.25M         *** update number
  - code size: 937K to 1160K                *** update number
  - 37M type tests, most of them is_i32
  - compilation time now about 60% of total time
  - something a 
- BBV eliminates >75% tests on 3d-raytrace, should make noticeable perf difference
  - new tag scheme will also eliminate is_object, is_array, is_string
  - but: block versioning will increase compilation time
  - can we exclude compile time for the paper?
- Opinion: is_i32 peephole, keep or remove?
  - Removes trivial type tests at the IR level
  - Reduces what the type analysis can eliminate somewhat (makes us look better)
- Ran DMD's profiler
  - liveness analysis is slow, quadratic
  - getProp makes > 30% of exec time
- Implemented basic inline caching, 23% speedup on 3d-raytrace

TODO: basic type prop & type test removal
- For now, don't do delayed writes, always just write type tags
- isTypeOp, handle constant types

TODO: blog post about optimization, results
- 200 stars on github???
- difficulty of optimizing self-hosted code
- profiling, you don't actually know what's going on, complex codebase
- 3d-raytrace, prop access > 30% execution time

FIXME: string-fasta is slower than before? fast compile time, profile this ***

TODO: total time vs exec time in stats

FIXME: getPropIdx runs for every global call????? noooo
- verify this with a loop that calls print










[DONE] TODO: getPropMethod
make; ./higgs --stats benchmarks/sunspider/3d-raytrace.js
- before:
    exec time (ms): 846
    comp time (ms): 388
    code size (bytes): 1111224
    num call_prim: 1369740
- after:
    exec time (ms): 1003
    comp time (ms): 608
    code size (bytes): 1160565
    num call_prim: 1250309
- compilation time now really dominates
- exec time went down but total time went up!

[DONE] FIXME: map_prop_idx produces idx 0
- obj proto map id is 0!

[DONE] FIXME: exceptions thrown by eval can't be caught in JS

[DONE] TODO: stat for all version counts, 1 version, 2 versions, ...
- Can compute this incrementally
- When going from 3 to 4 versions, remove 1 from 3, add to 4

[DONE] TODO: num blocks vs num versions stat, remove num instances

[DONE] TODO: compare ./benchmark.py times to CC2014 branch, to show Marc
- Much faster on some benchmarks, but slower in others
- Compilation time seems to be the problem

[DONE] TODO: check that we're measuring comp time properly

[DONE] TODO: specialized getPropIdx with basic inline caching
time ./higgs benchmarks/sunspider/3d-raytrace.js    real 1.123s
time ./higgs benchmarks/sunspider/3d-raytrace.js    real 0.869s
- Pass a pointer to the D string from the string constant if known
- Give the maps a 64-bit id as you do for instrs, have a few cache slots (4?)

[DONE] FIXME: block.getName, CodeFragment.getName called when not generating ASM?

[DONE] TODO: profiling
- getPropIdx quite slow
- liveInfo is ~10% of exec time
- getPropIdx is ~30%

[DONE] TODO: getPropElem for array elements
- currently 1.8M primitive calls
- now 1.37M

[DONE] TODO: specialized getPropLength primitive

[DONE] TODO: getPropField with first level obj access inlined
- keep small so just this gets inlined
- inline only where appropriate in ir/ast.d
- slows down compilation time hugely, unexplained by minor code size bloat

[DONE] TODO: rename getPropObj to objGetProp

[DONE] TODO: smaller lt for inlining, ltIntFloat

[DONE] TODO: log prim call names for 3d-raytrace
- lots of getProp
- lots of lt
- lots of add from ++ (fixed)

[DONE] TODO: $rt_addInt for ++ operator
- check stats for 3d-raytrace

[DONE] FIXME: mulIntFloat decreases perf on 3d-raytrace
./higgs --stats --e "print(numC); print(numF);" benchmarks/sunspider/3d-raytrace.js
- could we be hitting the fallback case often?
- collect stats using global vars
  - number of calls vs number of fallbacks
- mulIntFloat: 301K calls, 6K fallbacks
- addIntFloat: 317K calls, 4K fallbacks
- will have to wait until type prop to know

[DONE] TODO: $rt_mulIntFloat
- test perf on 3d-raytrace

[DONE] TODO: $rt_addIntFloat, smaller primitive for inlining
- doesn't make a big difference on 3d-raytrace

[DONE] TODO: peephope opt, see $rt_getPropObj
time ./higgs --jit_genasm --e "print(\$rt_getPropObj.irString())"
not_exit(3986):
$15 = phi [if_true(3965):0 => false, if_true(3965):1 => true]
if_true $15 => if_true(3981), or_sec(3984)
- Should be the only phi node in this block
- Should be no other instructions

[DONE] FIXME: GC/segfault bug with v8bench/crypto... heisenbug
- run outside of tests
- log when GC happens
- segfaults before GC!
$0 = is_const $10
$0 = eq_const $9, $10
ret $0
if_true $2 => if_true(12273), if_false(12274)
Segmentation fault (core dumped)
- Stack overflow

[DONE] FIXME: empty fun, cmp eax, 0
- see 200m_calls

[DONE] FIXME: irString followed by call crashes
- add test for this

[DONE] FIXME: loop incr, redundant jump to immediately following block
time ./higgs --jit_genasm --e "print(test.asmString())" benchmarks/micro/200m_loop_incr.js 
- not a stub, shouldn't happen
- naive writing, never rewritten?

[DONE] TODO: 200m_loop_incr microbenchmark

[DONE] FIXME: [1,2] == [1,2]

[DONE] TODO: proper struct for ValuePair
- methods, toString, isHeapPtr, isNull, isLayout, etc
- constructor taking a refptr & type

[DONE] TODO: examine uses of valIsLayout, refIsLayout in D code

[DONE] TODO: eliminate valIsString from D code

[DONE] TODO: add more logging for this error
Assertion failed (runtime/vm.d@697): invalid stack slot index
core.exception.AssertError@runtime/vm.d(697): invalid stack slot index
----------------
./test-higgs(onAssertErrorMsg+0xb0) [0x6ba054]
./test-higgs(_d_assert_msg+0x45) [0x69a065]
./test-higgs(runtime.vm.Word runtime.vm.VM.getWord(int)+0x9b) [0x6241a7]
./test-higgs(compileEntry+0x43) [0x681647]
[0x2aff3d1ee80f]
./test-higgs(runtime.vm.ValuePair runtime.vm.VM.exec(parser.ast.FunExpr)+0x6e) [0x6253a2]
./test-higgs(runtime.vm.ValuePair runtime.vm.VM.load(immutable(char)[])+0x83) [0x625537]

[DONE] FIXME: esprima test fails
- add new regression test

[DONE] TODO: eliminate valIsString from JS code

[DONE] Meeting:
- New wider type tags
- More debugging tools, tracing instrs, stack printing
- Conf invite in Sweden
  - rejected, suggested that Tom may apply, promote Higgs

[DONE] TODO: use ValuePair more in runtime/object.d, for safety?
- who uses getPropObj, newObj, newClos?
- might make most sense for newObj, newClos
- newObj should definitely take a ValuePair for the proto value

[DONE] FIXME: segfault on Higgs init
jump => for_test(3729)
$10 = load_refptr $9, 0
$0 = eq_refptr $10, null
$0 = load_mapptr $9, 16
$11 = map_prop_idx $0, $22, false
Is the map null?
- Seemingly not null, but getPropIdx segfaults
- str ptr seems corrupted
- gotta log who's calling getPropObj
  - can you traverse the stack using VM.visitStack?
- stack overflow is the problem

[DONE] TODO: util, as.printStack

[DONE] FIXME: $rt_getProto not working? proto value we get is corrupted, zero type tag
- value properly set in newObj
- seems to work with object in the console
- proto corrupted during object expansion
- minNumProps wrongly handled wrt reserveSlots

[DONE] FIXME: prototype needs a type tag
- store in slot 0?
- need to move closure pointer to slot 1
- newObj, newArr need to reserve a hidden prototype slot too

[DONE] TODO: adjust D uses of newObj, newClos
- grep for REFPTR

[DONE] Meeting: to be shown: disassembly for fib, microbenchmark results
- completed and debugged new stub scheme, branch rewriting
- various machine code optimizations
  comp time     -42%
  exec time     -19%
  code size     -14%
- made disassembly strings much much faster
- ran microbenchmarks
- recuperated inlining, type analysis code from cc2014 branch, basic inlining working
  - even only inlining small primitives generally doesn't pay for itself
  - does win out on 3d-raytrace, cuts prim calls by more than half
- started looking at IR, ASM for prop access, optimizing inefficiencies
- idea: shape system with types for object fields
  - by testing for a specific shape, instantly gain invaluable info about an object
  - could insert shape test instruction, generate many basic block versions (up to 4?)
    s = obj_get_shape o (s is say int32)
    v = obj_get_val(o, s, propStr)
    In optimized case, shape idx and prop idx gets us a constant, or
    a constant type.
  - could work for the global object too
  - solves the undefined problem, advantage over TI!
- the plan:
  - first basic inlining, tweak heuristics
  - get type prop, type analysis working
  - rewrite new primitives with smaller inlinable part, hand-inlining, hand-tuning
  - 1st level type tags for objects, arrays, closures
  - see how much time is left
  - reg alloc, some gains, but probably not that much
  - global prop access idea, known not missing?
  - shape system?
    - may want to leave type spec out until next paper
    - may be too much to explain
    - but, could start with inline caching
- Marc says: prioritize inlining of add, sub, mul, etc.
  - rerun microbenchmarks
- Marc says: aim for having satisfying perf a month from now
  - set milestone

[DONE] TODO: adjust GC code for new type tags

[DONE] TODO: isHeapPtr(Type type), useful for sanity checks
- grep for REFPTR

[DONE] TODO: change layout system to use new alloc instructions

[DONE] TODO: tweet that presence at dconf is confirmed #dlang #dconf
It's official, Higgs and I will be returning to DConf in 2014! dconf.org #dlang #dconf

[DONE] FIXME: test runner, FFI depend on type tag values?
- grep for get_type

[DONE] TODO: fetch type analysis from cc2014 branch, make it compile

[DONE] FIXME: getProp calls toBool, this is wrong!
time ./higgs --nostdlib --stats benchmarks/micro/10m_getprop.js
- Can we assume that if (prim) produces a boolean? should be able to
  - don't design primitives that have weird polymorphic return types
time ./higgs --nostdlib --stats benchmarks/micro/10m_getprop.js
exec time (ms): 3200
comp time (ms): 12

[DONE] TODO: upgrade dmd to 2.065

[DONE] FIXME: segfault on throw_in_finally
make; ./higgs --nostdlib "tests/core/exceptions/throw_in_finally.js"
- Doesn't have to do with the peephole
- Don't want to inline $rt_throw
  - but why does it segfault?
- Not inlining throw doesn't fix it
- doesn't get to throwExc
- something screws up during IR gen
- inlining + exc produces empty block

[DONE] TODO: --jit_trace_instrs

[DONE] FIXME: $rt_obj_ofs_next not inlined in $rt_obj_get_next, why?
- IR gets doesn't get generated when entry stub is hit, no entry stub for primitives!
- move inlinePass call into astToIR!

[DONE] TODO: peephope opt for IsTypeOp with constant

[DONE] TODO: simple ad-hoc, rule-based inlining
- benefit: keep the old type analysis
- inling once at IR gen time, no recompilation
- inling specific primitives
- to begin, only inline small runtime primitives
- should be able to speedup getProp hugely

[DONE] TODO: if call has no uses, no need to copy ret regs to out slot

[DONE] TODO: grab ir/inlining.d and jit/inlining.d from CC branch

[DONE] TODO: simplify return from primitive functions?
- Are we doing frame size checks in there?
- test 200m primcalls again
time ./higgs --nostdlib --stats benchmarks/micro/200m_primcalls.js 
- hack it for now
- before
  exec time (ms): 1810
  comp time (ms): 1
  code size (bytes): 40890
- no noticeable time difference!

[DONE] TODO: microbenchmarks, big loop with either getProp, getGlobal, fn call
- also run with --stats, look at num prim calls
time ./higgs --nostdlib --stats benchmarks/micro/10m_getprop.js
  10M getprop
    exec time (ms): 4884
    comp time (ms): 10
    num call_prim: 210000041    *** 210M primitive calls, inlining will help
    num map_prop_idx: 10000001
    is_refptr: 20000002
    is_const: 20000001
    type tests: 40000005
  10M getglobal
    exec time (ms): 154
    comp time (ms): 3
    num call_prim: 0
    num map_prop_idx: 0
    type tests: 0
  200M add
    exec time (ms): 3637
    comp time (ms): 2
    num call_prim: 200000000
    type tests: 400000000
  200m primcalls
    exec time (ms): 2120
    comp time (ms): 2
    num call_prim: 200000000
    type tests: 0
- worth studying, discovered some hidden type tests
- getProp does about 20 calls per access, about 50% exec time is prim calls
- inlining will be crucial, especially inside getprop

[DONE] FIXME: getprop does 10M is_f64 tests?
- use of $rt_ns in getPropObj

[DONE] TODO: fix num prim calls stat

[DONE] TODO: compare speed against master branch with ./benchmark.py
new
  comp time (ms): 95            -42%
  exec time (ms): 512           -19%
  code size (bytes): 618873     -14%
old
  comp time (ms): 163
  exec time (ms): 631
  code size (bytes): 715050

[DONE] TODO: memberOpnd? could optimize call code further

[DONE] TODO: as.comment, try avoiding calling if jit_dumpasm is false

[DONE] FIXME: branch rewriting did not shave end of blocks in getPropObj
make; ./higgs --jit_genasm --e "print(\$rt_getPropObj.asmString())"
call_cont(3D2B):
; $0 = eq_refptr $7, null
mov rax, [qword r14 + 56];              498B4638
cmp rax, 0;                             4883F800
je branch_if_true(3D2D);                0F848C000000
nop1;                                   90
nop4;                                   8D742600
branch_if_join(3D2F):
if_join(3D2F):

Clearly branch_if_join is immediately after. Should be immediately queued.
Will need to log things specific to getPropObj branches

What those jumps have in common is that neither of the targets are stubbed.
They got rewritten twice.
Most likely, the first rewrite simply did not remove the mov...

[DONE] TODO: getBranchEdge, should probably avoid:
  - generating succState
  - doing getBlockVersion to get a successor version
  - immediately doing move generation
- wastes time and memory on unexecuted targets
- only store the predState and target block at first
- can lazily generate moveList when compiling branch edge
- if isNoop, eliminate the branch edge
- want to do repatching in compile loop, when compiling branch edge

[DONE] FIXME: call_prim to rt_obj_get_next taking 3 constant args, why?
- only needs one argument
- we don't check if the hidden arguments are needed
- could just assert they have no uses
- argc seems necessary to traverse the stack

[DONE] FIXME: does the GC need the closure argument?
- closure argument not needed per-se
- GC fails to find return address in ret addr map
- leftover corrupted data with the wrong tag?
- Do we ever write values on the stack without a type tag?
  - odd interation with a regression test...
- bug in get_ir_string, missing setOutType

[DONE] TODO: optimize branch edges
- if target is directly next, not write jump?

[DONE] TODO: optimize if_true branch shape

[DONE] TODO: asmString log call cont stubs
make; ./higgs --jit_genasm --e "print(\$rt_getPropObj.asmString())"

[DONE] TODO: optimize branch shape for integer less-than

[DONE] TODO: optimize direct jump shape

[DONE] TODO: asmString, display gaps!
; ### NN bytes gap ###

[DONE] TODO: if we're the last block, don't pad with nops!

[DONE] TODO: avoid writing blockIdx when neither target is a stub
- need to check if queued for compilation also
  - workList.canFind(b)
make; ./higgs --jit_genasm --e "print(\$rt_add.asmString())"

[DONE] FIXME: issue with neither targets being stubs
- not writing blockIdx causes segfault
- problem happens with is_i32, right when compiling a stub
- error with nop() function causing stack overflow

[DONE] TODO: optimize final jump ordering when rewriting final branch
- BranchShape
- again need to check if successors are queued?
just compare startIdx... value is max if stub!

[DONE] TODO: way to remove code block strings in specific range, delStrs
- Needed when rewriting branch or patching stub
- range [startIdx, endIdx[

[DONE] TODO: asm strings, reimplement using an array of indices to lists of strings

[DONE] TODO: make blockIdx 32-bit so move is smaller

[DONE] TODO: pushfq, popfq for debugging w/ printInt, printStr
9C PUSHFQ
REX.W + 9D POPFQ 

[DONE] FIXME: problem with tests/core/ffi/ffi.js
- FFI call borking, issue with stubs?
- Might be an issue with the return value handling, call continuation
- FFI probably does not need genCallBranch... Better served by plain genBranch

[DONE] FIXME: throwExc needs to JIT compile the exception branch

[DONE] FIXME: stdlib init fails
label "FALSE2" already defined at position 410858
- call does a conditional jump to compute the total frame size
- should try to move this computation out of the final branch part

[DONE] Meeting:
- contribs, multiple fronts:
  - self-hosting
  - type tagging scheme
  - BBV
  - incremental compilation
  - incremental inlining
- incremental inlining decreases execution time on `make test`
  - right now, even with poor inlining, doesn't make benchmarks slower
  - old aggressive inlining might be slower, increase compilation time
- paper-wise, might be better to do simple rule-based inlining
- proposal: simple inlining for DLS paper
  - focus on BBV, improving code gen, fixing incremenetal compilation quirks
- stubs: might be able to have one stub for all branches
  - truer to the lazyness goal
  - allows better contiguous code
- CC or PLDI paper on incremental compilation?
- Bourse DIRO!

[DONE] FIXME: issue with recursion, start position is already marked
- may need to patch the cont stub, still used for deeper calls

[DONE] FIXME: 1 + 2 doesn't produce the right output
- Return not working?
- Are we manging the return type reg?
- Value+type correct after add...
- Value+type correct at first level return
- Second return gets incorrect value and type

[DONE] FIXME: 1 + 2 doesn't work
make; ./higgs --nostdlib --e "1 + 2"

[DONE] TODO: --noruntime flag, useful for debugging, with --jit_dumpinfo
- make it automatically imply nostdlib
- debug simple expressions, make test produces too much output

[DONE] FIXME: setRetEntry, calls getCodePtr to get a pointer to the call
continuation code. The call continuation branch is not yet instantiated.
- Can we make call returns go to BranchStub?
  - doesn't really work
- Should force cont branch to get compiled?
  - what about exception branch... don't want to force that to be compiled
- For exceptions, can probably trigger compilation manually during exception handling
- If we say call cont must be compiled, we still don't get an address immediately
    auto retAddr = retCode.getCodePtr(vm.execHeap);
    vm.retAddrMap[retAddr] = RetEntry(callInstr, callCtx, retCode, excCode);

[DONE] For efficiency, probably want returns to go to special stubs
- Compile whole sequence after return all at once, more elegant and optimal
- ContStub will:
  - patch its calling block version, rewrite its final branch
  - queue the proper return branch to be compiled
  - remove the old RetEntry for the ContStub
  - create a proper RetEntry for the compiled return branch
- Could use a unique return stub?
  - Since we patch the calling block
  - Could set the call blockIdx in a special register
- Probably don't want a unique stub
  - Want to have some specific RA we can track!

[DONE] FIXME: we hit a branch stub, but the blockIdx is corrupted
- Seems to contain a pointer value instead
- corruption during reference patching because of getBranchStub

[DONE] TODO: rework genBranch
- block idx is available when compiling block (fragList.length)
  - store in scrReg[0]? be careful wrt calls
  - check if either target is a stub first
- may need to pad until endIdx with noops
  - also assert that we aren't going past endIdx if rewriting

[DONE] TODO: rewrite srcBlock final branch in compileBranch

[DONE] TODO: refList patching, if jumping to uncompiled block, jump to branch stub instead

[DONE] TODO: generate code for BranchCode in code gen loop
- Add call to prelGenFn

[DONE] TODO: BranchCode should store a closure that generates its code
- Deferred codegen
- Also store list of moves

[DONE] TODO: rework compileStub
- only write branch edge to execHeap once stub is hit, unless we know it will be taken
- store pointer to BranchCode as outgoing target

[DONE] TODO: generate stub[i], getStub(targetIdx)
- don't need special spill code for now, no reg alloc yet
- Receives blockIdx in scrReg[0]

[DONE] FIXME: string interning, no cleanup on GC? Can we make splay faster?
- This is already done correctly!

[DONE] TODO: try creating smaller versions of slow benchmarks for unit tests
    shootout/lists
    sunspider/string-base64
    sunspider/string-fasta
    v8bench/splay
- at least keep them tested!
- name with _quick

[DONE] TODO: move loop_big_incr into benchmarks/micro?

[DONE] FIXME: jump removal opt, conditional or not, doesn't matter
- Don't check if jmp

[DONE] TODO: Modify CallCtx for improved inlined stack management
CallCtx.extraLocals => obvious from fun
Add: CallCtx.spOffset, CallCtx.totalLocals? Maybe just extraLocals

[DONE] Meeting:
- IRFunction.asmString, see generated code
  - Found bugs and issues with ASM comments, markEnd logic
  - visualization useful
- Redundant jump opt
- Now obvious: stubs should probably be out of line
  - But should we implement this later?
- DLS Paper, coming soon, what do we absolutely need?
  - Objective: show less checks, better running times
    - Run benchmarks in a loop?
  - Inlining, type prop, eliminate type checks
  - Type analysis
  - Reg alloc? basic
- Bourse DIRO

[DONE] FIXME: corrupted ASM comment in the middle of stub
    branch_if_join(36CC):
    jmp if_join(36CC);
    if_join(36CC):
    ; Stub of if_join(36CC)
    mov [qword r15 + 48], r14;              4D897730
    mov [qword r15 + 56], r13;              4D
    ; if_true $0 => if_true(36CA), if_join(36CC)896F38
- Try disabling jmp opt, see if it helps
  - Seems to fix the problem, but now the commend is just before if_join?
    if_true(36C3):
    $0 = is_i32 $22
    if_true $0 => if_true(36CA), if_join(36CC)
- The if_true compiles to nothing because is_i32 generates branches,
  the ASM comment gets placed after the branch code

[DONE] TODO: resume projet for bourse DIRO
- Mention github stars, Mozilla continues funding us, interest from Facebook

[DONE] TODO: asmString, don't print blocks with zero length?
make; ./higgs --jit_genasm --e "print(\$rt_add.asmString())"
- or just no whitespace after ***

[DONE] TODO: try optimizing away empty branch edges
- Time the result
- can we integrate this in genBranchEdge?
- Simpler alternative: if block immediately follows branch edge, 
  don't write jump.
  - Query code gen queue to know if jump is necessary
  - Have special utility function just for generating final jumps ***
time ./higgs tests/core/regress/loop_big_incr.js
before: 36.4
after: 31.3

[DONE] TODO: IRFunction.asmString()
- Order by address
  - no need to sort, just keep track of traversed, do smaller addr first
- Branch code too
- This should be quick to code

[DONE] TODO: LocalIdx => StackIdx
- Not unsigned

[DONE] TODO: partial support for `quasis` as multi-line strings only

[DONE] TODO: update CV for bourse DIRO

[DONE] TODO: wiki, add enum of missing features

[DONE] TODO: in About Me on pointersgonewild, link arxiv paper, mention it's a tech report

[DONE] TODO: look for JS FFT implementation
- there is one in kraken 1.1
- ask on Twitter if someone knows of a simple JS FFT

[DONE] TODO: e-mail Marc about bourse DIRO. Mention e-mail suffices.

[DONE] TODO: take a look at Mozilla regression tests
http://hg.mozilla.org/mozilla-central/file/8c5a94ba1096/js/src/jit-test/

[DONE] TODO: if to same if opt pattern, see $rt_getPropObj, $6
- if testing the same value and value is not from succ, will branch the same way

[DONE] FIXME:
h> try { 'foo' + $nullptr } catch (e) { exc = e }
h> exc.toString()
object
Needs to inherit from Error.prototype

[DONE] TODO: add trace info to exception objects
- throwError already allocates in heap, fair game
- can make helper functions in throwExc to set the current position at each
  call level

[DONE] TODO: probably want to be able to set a target for throw?
- Want to unwind the stack, set the position on the exception value
- Call some runtime function that does throw
  - Eliminates need to set srcPos on throw instrs
  - genRtCall("throwExc");

[DONE] TODO: add source position info for call instructions and throw instruction
- Do this in genCallTargets?
- Modify stack trace code to show source positions
- Map of call sites to source pos in IRFunction
  - Might want to just have sourcePos ptr on IRInstr, simpler wrt inlining
  - More robust with IRInstr

[DONE] FIXME: block cap hit... Block version map needs to be per-callCtx?
- uncomment block cap hit print, put in version(debug) block
- see $rt_getPropObj, $6

[DONE] TODO: migrate esprima parser test from Tachyon

[DONE] TODO: move some of the misc Tachyon tests to the new test runner

[DONE] FIXME: peephole opt bug
- streamline failing test
- add new test to core/regress

[DONE] TODO: prepare beta mloc/midiro talk

[DONE] TODO: call to non-function, try to recover fn name from IR
- make a function for that in ir/ir.d, getCalleeName(IRInstr callInstr)

[DONE] TODO: move SunSpider tests to test runner

[DONE] TODO: move shootout tests to test runner

[DONE] FIXME: enumeration issue, duplicates
h> a = { x:1 }
object
h> b = Object.create(a)
object
h> b.x = 2
2
h> for (k in a) print(k)
x
h> for (k in b) print(k)
x
x
- Need a way to check if somewhere in the inheritance hierarchy an enumerable
prop of the same name exists
- Make regression test, tests/regress/for_in_dup.js
- When solved, add for_in test, close github issue

[DONE] TODO: move V8 tests to test runner

[DONE] TODO: make sure to mention arxiv paper on wiki, basic block versioning

[DONE] TODO: make test-higgs not skip main
- Run test runner with same binary
- Notify Tom of change

[DONE] TODO: fix unsupported base issue
- add test, stdlib/object
- Tom is working on it

[DONE] TODO: blog, use subheaders? (More talks coming, new contributors, more seriouser)
- paper on arxiv
    http://arxiv.org/abs/1401.3041
- Budapest talk imminently
  - expect detailed blog post on BBV & incremental JIT
- DConf 2014
- incremental JIT in master branch, no reg alloc, perf about the same
- working on incremental inlining
- bug fixes, thanks to toledo chess
  - more bug fixes, unary + and -, regex, thanks to zimbabao, toledo
  - Higgs now more JS compliant
  - new test framework, moz/v8 tests
- travis test system
- contribuse OSS, DOM-free JS code, help us test & debug Higgs
  - always looking to grow our collection of tests

[DONE] FIXME: missing runtime primitive segfaults?
- Does indeed segfault in the shell

[DONE] FIXME: Higgs REPL, should return value of last expr if several

[DONE] TODO: simple tests for csv lib?
tests/lib/csv/ csv.js, infile.csv

[DONE] TODO: move basic FFI tests to test runner
tmpnam, make sure that returns string of length > 0

[DONE] TODO: look at link issue pointed out by zimbabao
function set_get_test_function() {
    var link = $ir_make_link(0);
    var s = "1234";
    print($ir_get_type(s));
    $ir_set_link(link, s);
    var val = $ir_get_link(link);
    print(val + " : " + $ir_get_type(val));
    val = $ir_get_link(link);
    print(val + " : " + $ir_get_type(val));
}
set_get_test_function();

[DONE] TODO: proper 1 / (-1 * 0) handling, negative operator as -1 times zero,
multiply handling of 
If the multiplication isn't truncated (by one of the many ToInt32()/ToUint32()-coercing operators),
then we dynamically branch for both overflow and negative*zero.  We can also special case various
multiply-by-constant cases to avoid one or both branches.  (Note, even when multiplication is
truncated it can overflow making * kindof a lame duck.  In asm.js, we give it the type (doublish,doublish)->double
and then we separately define multiplication by small-enough constants as having type int->intish.
This suckiness is what motivates Math.imul.
We just branch on zero to an out-of-line path that does the signed check.

[DONE] FIXME: killing of values in removeDead... Doesn't account for recursive
inlining. Should traverse chain of ctxs to test if callee is in the chain.
- CallCtx.contains(IRFunction fun)

[DONE] TODO: pull from master

[DONE] FIXME: sunspider/3d-raytrace borks with inlining enabled
./higgs benchmarks/sunspider/3d-raytrace.js
run-time error: unsupported types in strict equality comparison
- Invalid base in property read
- Inlining of getProp is wrong?
- base argument of getProp seems wrongly mapped
- localIdx is correct at time of call to $rt_se
- The type we get is retaddr... We seem to be off by 2?
... Draw this specific situation on paper
When calling getProp, the this/base type tag is already corrupted.
- Sometimes gets a zero type tag too...
Why is the this value of Triangle.prototype.intersect corrupted???
The argc value is correct, so is the type tag!
- Only the this value is corrupted
This problem happens with getProp a lot, in several places... wtf is wrong with getProp?
- Should probably assume that getProp gets inlined wrong somehow?
- getProp tends to have other functions inlined inside it? Is the inlined return wrong?
  - Many many things get inlined in getProp, then we get a failure
Hypothesis: getProp needs to be inlined for this to fail?
Seems to be getPropObj that's inlined in getProp that fails?
phi move seems to be at fault:
move from: $17 = arg 4 "obj"
move to: $17 = arg 4 "obj"
  src: [qword r14 + 136]
  dst: [qword r14 + 800]
No mapping of arg in src, but mapped in dst...
Killed by removeDead...
Might indeed really be dead!
Moving from callee argument to caller argument slot, bad

[DONE] TODO: integrate new test system

[DONE] TODO: pull zimbabao's PR

[DONE] TODO: exception handling in inlined context
- Can use regular exception handler, however? Yes
  - Takes the exc value off the stack
  - This is a BranchCode object
  - Could also just generate our own, avoids need to keep JIT objects in CallCtx

[DONE] FIXME: seem to now be failing in exceptions test
./higgs --nostdlib tests/exceptions/try_loop_getprop.js
- Does getprop to null, fails
- When inlined, throw becomes a jump?
  - can use exc handler also, performance not so important
- All the ops that can throw need throw handler code, including get_global
  - Need some kind of getExcHandler fn?
  - Returns a code fragment
  - Problem: need to compile handler after throwing instr
  - Ideally, compile at throwing instr, store in CallCtx???
  - Only call_prim can cause this
- CallCtx.getExcHandler(curHandler = null)?
  - seems like that would work!

[DONE] FIXME: no handling for two levels of inlining
- loop test that uses getProp?
    make; ./higgs tests/regress/jit_getprop_arr.js
- use extraLocals from previous level when computing current extraLocals
- still segfaults, probably want simpler test
    make; ./higgs loop_test.js
We crash at the second inlined call to str_ofs_data...
- We aren't getting the same entryVer object
- extraLocals... can't pop them all at once when returning if multiple levels
- want extraLocals and totalLocals...
- Also want to be able to map arguments across *multiple levels* of inlining

[DONE] Meeting:
- Sent submission for DConf
- New contributions, regexp fix, missing array functions
- Multiple bugfixes
- More conformance bug fixes
- Inlining, slight perf gain, ~12%

[DONE] TODO: test full higgs init with inlining

[DONE] TODO: getBranchEdge shouldn't need assembler argument

[DONE] FIXME: benchmark inlining on for incr loop (see existing tests)
make; time ./higgs --nostdlib tests/regress/loop_big_incr.js 
noinline: 40s
inline: 36s
- seems to infinite loop, need to look at return values, args
- loop i stops being incremented at 5000
- try printing return value of add
- Not executing phi nodes after the return? ***

[DONE] FIXME: foo.irString() before foo() fails
- irString causes odd things to happen
- make regression test for this too

[DONE] FIXME: bug found by zimbabao
- something with phi nodes, liveness?
    while (size-- > 0)
    $5 = phi [call_cont(ED8A):0 => 4, call_cont(EDB9):0 => $0]
    $0 = set_str "sjhsjsh", <link:NULL>
- There is no call to rt_sub! test expr wrongly evaluated
  - some phi simplification might be failing
- Problem is with tmp alloc, tmp escapes block, used by phi node
  - But used within same block
- sunspider/crypto-aes still not working properly!

[DONE] TODO: integrate regexp fix PR

[DONE] TODO: see how far along we get in make test
- global object test, goes into infinite loop, possibly 2-level inlining

[DONE] TODO: test on trivial loop example first, with --nostdlib
for (var i = 0; i < 10000; ++i);
- Inlines call to lt, but execution stops immediately (lt returns false)
- lt returns false, arguments are probably mapped wronge (inverted?)

[DONE] TODO: connect the inlining bits in call_prim
- setup new CallCtx
  - store contSt
- setup new CodeGenState
  - map args to parent values
- adding of extraLocals
- jump to entry

[DONE] TODO: email Marc, Laurie, Clark about ref letter

[DONE] TODO: start with return handling for inlining, no exceptions yet
- Probably don't want to jump to regular return branch from inlined call
  - Don't want to use the move register, want to get a branch edge for the call cont
  - Need to track the IR branch edge object
  - Generate efficient code upon return
- can test on 3d-raytrace

[DONE] TODO: write/send submission for DConf 2014 , title + abstract
- Deadline Jan 31st
- 21-23 May, Menlo Park

[DONE] FIXME: +{} should be NaN, +[] should be integer 0
- currently does 0+x
- what does the spec say?
ToNumber(GetValue(expr))

[DONE] TODO: get_ir_str

[DONE] FIXME: X86Opnd(-1) doesn't fit in 8 bits?
- see getWordOpnd

[DONE] TODO: proper system to map values to stack slots in CodeGenState
- Needed for handling of inlined args
- Need to be able to map a value to a specific stack slot ***

[DONE] TODO: inform Andrei
- Marc willing to pay for travel + hotel

[DONE] TODO: liveness information during inlining
- fix removeDead
- Do we even need to query this??? Can probably ignore parent values in removeDead

[DONE] TODO: send toledo chess link to Marc

[DONE] Meeting:
- added generated code size stat, num call_prim, num dynamic calls
- large majority of calls are primitive calls (>70x more) in several benchmark
- began inlining work
- have system to trigger recompilation of call sites on inlining, code patching
- working on stack value tracking in inlined calls, branch and exc edges
  - all managed in backend, IR not transformed
- DConf 2014. Could replace Australian conf, coincide with Mozilla visit?

[DONE] TODO: --jit_noinline flag
- 3d-raytrace inline:
exec time (ms): 2698
comp time (ms): 436
code size (bytes): 1151903
- noinline:
exec time (ms): 2528
comp time (ms): 420
code size (bytes): 919875

[DONE] TODO: test, long loop with getProp and try, eventually set base to null,
throws an exception in an inlined context

[DONE] TODO: patching mechanism for when recompiling
- VersionInst needs a next version var
- BlockVersion method for patching?
- put next var in base class?
- should assert that the patch code can fit within the current block length
- assert that the endIdx is set in length computation

[DONE] TODO: sketch recompilation mechanism for inlining
- spill regs, call?
- need to set the CallCtx, contained in BlockVersion

[DONE] FIXME: code size statistic, sum up generated code
- markEnd should do this?
- adding counter/recompilation code makes code size go from to 0.9 to 1.15MB

[DONE] TODO: add counter variable (uint32) on VersionInst
- Implement incrementation code in call_prim, test performance

[DONE] TODO: ask on Twitter if people have DOM-free JS code to help test & benchmark the Higgs JS JIT
Do you have any DOM-free JS code to help test & benchmark the Higgs JS JIT? https://github.com/maximecb/Higgs

[DONE] TODO: look at incremental inlining notes, new notes file specifically on this
2014-01-16 Inlining.txt
- what did we say wrt fn arguments?

[DONE] FIXME: chess program, The other bug is because you changed the 'ply' variable
to be 1 (validate legal movement) instead of 2, the chess program only does
search when ply is 2 or higher. So the game works after changing it to 2 and
solving the other bug temporarily (using Math.floor(B/x))

[DONE] FIXME: bitwise operators OR, AND and XOR, your compiler rounds the operands
with Math.round instead of Math.floor
also happens with the bitwise complement operator
For example, 3.5|0 gives result 4

[DONE] TODO: double to signed integer conversion using truncation
F2 REX.W 0F 2C /r
CVTTSD2SI r32, xmm/m64
- revise toInt32, toUint32

[DONE] TODO: add some basic lib tests that just do require('lib/stdio') and stdlib...
- easy to call stdlib/stdio fn?

[DONE] FIXME: Number + Boolean fails, 0+true generates "0true" instead of 1
- check every operator where Boolean can be used with Number
  0 + true == 1
  1 + null == 1
  1 + false == 1
  null + true == 1
  true + null == 1
  true + true == 2
  true + undefined == NaN
- once working, push to master, notify Oscar Toledo

[DONE] TODO: re-fetch improved $rt_add, $rt_sub, etc from cc2014

[DONE] TODO: Inlining heuristic... counter?
- could have inline counter with threshold, eg: 10K
  3d-raytrace does 68M call_prim
  assuming 500 main ops, 136K calls per op on average
  10K probably reasonable
- Try instantiating counter, and logging how many times it gets hit, source location
  - for 3d-raytrace, 10K gets us around 190 call_prim instances, 20K gets 122, 5K 221
  - hot call sites fairly well spread, may need to put threshold lower
    - find optimal threshold based on benchmarks

[DONE] TODO: how many getPropIdx calls do we do in big benchmarks, how many calls?
- add counter for getPropIdx, call_prim, call
- much less getPropIdxs than type tests, but these are probably much slower
- number of call_prim dwarves even number of type tests
  - over 100x as much as dynamic calls
- counters make a noticeable difference in execution time, good news

[DONE] TODO: put paper on arxiv.org? Yes

[DONE] Meeting:
- next priority: type prop, inlining, reg alloc, jump opts, inline cache
- next paper will probably be about type prop... but would also like better perf
- how many getPropIdx calls do we do in big benchmarks, how many calls?
- usenix
- Mackenzie scholarship, possibly
- going to need to start on mloc.js talk soon, beta due by end of month
  - Marc: give practice talk at MiDiro

[DONE] TODO: create wiki FAQ page, why D
https://www.youtube.com/watch?v=hJUNHX0vakI&feature=youtu.be&t=20m12s

[DONE] TODO: add benchmarks/kraken-1.1/ai-astar.js to parser tests
- can we also parse ai-astar-data.js reasonably fast? yes

[DONE] TODO: talk to Tom about JITted FFI

[DONE] TODO: make dummy codegen function for JITted FFI

------------------------------------------------------------------------------

[DONE] Milestone IV: All tests and benchmarks working
- Will require GC

[DONE] TODO: push to master branch once all benchmarks working

[DONE] TODO: inform Marc of progress

[DONE] TODO: run ./benchmark.py, get first results, compare to past
- comp time slightly slower, but more inclusive (ast to IR)
- bigger benchmarks generally faster
- this is with no inlining!

[DONE] TODO: pass all tests

[DONE] FIXME: earley-boyer fails after GC
./higgs benchmarks/v8bench/base.js benchmarks/v8bench/earley-boyer.js benchmarks/v8bench/drv-earley-boyer.js 
run-time error: undefined base in read of property "car"
- GC triggered by makeThisObj
- Create a new regression test
- Bug does seem to have to do with GC
- If we get undefined base, it's probably cause we got a getProp producing undefined
  - confirmed, both car and cdr are missing
  - propIdx is -1
The value we get for the base seems to be a number?
lst gets the number 0 as argument...
This should probably be the null value
Changing the code seems to affect when the bug happens!
- Changing the frame size?
Hypothesis: we write args above wsp/tsp before creating the this object
- These args do not get forwarded

[DONE] FIXME: GC during array allocation fails
- pushJITRegs not done, wsp/tsp not set

[DONE] TODO: implement get_heap_free instruction
- Generalize GetValOp? Not for this, need to compute value

[DONE] TODO: pass basic gc_collect test

[DONE] TODO: implement gc_collect instruction

[DONE] TODO: fixup GC code

[DONE] TODO: blog, Contribute to the Higgs JS Compiler
- No need to know how to program in D
- List of things people can contribute
  - Trying it out, finding bugs
  - Writing useful libraries
  - Implementing new JS features
  - Profiling to improve compilation speed
  - Support for ES6 features
- Link to wiki
https://github.com/maximecb/Higgs/wiki
- Link to issues page, link to wiki in post and in Higgs page
- Open issues on GitHub for
  JIT compilation time profiling
  Finding new benchmarks, adding them to "make test"
  Repackaging JS libs to be shipped with Higgs
- Link to contribution instructions on wiki
- Explain the Higgs roadmap
  Batteries included, easy canvas window, easy input lib

[DONE] TODO: fix ops to use setCallCtx
gen_get_str, gen_map_prop_name, gen_new_clos, op_get_ast_str, FPToStr, gen_call_new

[DONE] TODO: update wiki, reporting bugs, mention source/tests directory, PR

[DONE] TODO: split /programs into /benchmarks and /tests

[DONE] TODO: valIsLayout vs refIsLayout

[DONE] TODO: rename state.ctx to state.callCtx

[DONE] TODO: modify throwExc to take CallCtx argument

[DONE] TODO: test undef | 0, shift by undef, etc

[DONE] FIXME: "function() {} b = 0" fails to parse
- function is parsed as expression statement
- could we check that last tok was } ?
- the closing brace should end the statement parsing

[DONE] TODO: when entering compileStub or compileEntry, set callCtx pointer in the VM
- could use a function to set/unset, enforce null on entry, non-null on exit
  setCallCtx(ctx)
  setCallCtx()

[DONE] TODO: RAEntry should have CodeGenCtx pointer
- Rename to CallCtx, move to ir/ir?

[DONE] TODO: add canvas lib to open issues
- Detail some basic sample usage

[DONE] TODO: Supported JavaScript Features page on wiki
- link on PGW

[DONE] TODO: link to Quickstart guide, wiki on PGW

[DONE] TODO: reporting bugs Wiki page

[DONE] TODO: fill in stdlibs in list of libraries on wiki

[DONE] TODO: increase default str table size, use power of 2 sizing, eliminate modulo
- Initial size should be 16K

[DONE] TODO: eval a throw test

[DONE] TODO: load, eval instructions
- Need to compile a new unit, then jump to it, return to caller continuation
- May want to split compileUnit, generate special return code separately?
- Want a callUnit function?
- compileUnit could do a more minimal compilation of a unit, return VersionInst
- or maybe don't use compileUnit at all!

[DONE] TODO: unit test for global property access of prop from Object.prototype
- Need simple fallback for when prop isn't on global obj
- Won't this require spilling everything?
- Property could get deleted

[DONE] FIXME: unresolved global, no exception thrown
- We aren't checking for that...
- Default can spill all, have fallback

[DONE] FIXME: programs/regress/new_array, bug in toUint32
run-time error: unsupported value in toUInt32: 128
- Does this fix crypto benchmarks?

[DONE] TODO: factorize a genCallBranch wrapper for genBranch
- in jit/ops, before all the call instructions
- boolean flag to generate call throw path

[DONE] TODO: add new null(), new undefined() tests

[DONE] FIXME: segfault on null() call

[DONE] TODO: make call throw on non-closure work
- needed by 4 tests
- spill all, call throwExc
- jump over this code normally?
- how do we get the exc version addr?
  - could have wrapper host function with less arguments
    - actually want to call throwError anyways, not throwExc
  - pass vm, call instr, exc handler version
- define a throwCallExc function

[DONE] FIXME: many_globals test produces call to non-function
- check what type comes out of get_global

[DONE] TODO: refactor getProp/putProp to use wstring for propName

[DONE] TODO: test basic exceptions, throw

[DONE] TODO: implement throw
- calls throwExc, passing exc val, then jumps to address returned

[DONE] TODO: make call instructions do vm.setRetEntry
- Also need to generate exc path

[DONE] TODO: throwExc needs to set exc object
- If call instr is null, set exc object, use return branch

[DONE] TODO: refactor compileUnit
- KISS, return CodePtr for entry branch edge
  - setup stack manually
  - callable only once
- No longer need callFun in VM.exec
- set return address, exc handler at end of compileUnit
  - ra should be custom return BranchEdge
  - exc handler is also custom BranchEdge

[DONE] TODO: rewrite throwExc
- Need map of RAs to <VersionInst callVer, CodeFragment excHandler>
- Exception traversal needs current IRFunction
  - Throw/unwind code returns exc handler addr to jump to
  - If stack fully unwound, set exc value ptr in VM
  - Value passed to host is a D RunError object
- Normal call exc handler generates moves
  - Host places exc value on VM stacks before returning
  - Handler removes ret value, places in callInstr.outSlot

[DONE] TODO: define CodePtr type in CodeBlock

[DONE] TODO: VM.compile(), VM.queue(version), VM.addVerRef(), etc?
- grep for .refList, .compQueue
- split jit.d into jit/state, jit/util, etc

[DONE] TODO: rename Interp class to VM
- rename uses and interp directory as well
- Grep for interp, Interp, interpreter

[DONE] TODO: get_ast_str

[DONE] TODO: remove interp/ops.d
- move useful contents to jit/ops.d and interp/interp.d

[DONE] Meeting:
- new, apply working
- all of stdlib initializing
- all stdlib tests working
- most benchmarks working
  - missing some because of GC, exceptions
- compilation time stat, about twice as fast

[DONE] TODO: re-add compilation time stat
- try on 3d-raytrace, v8/raytrace
- about twice faster

[DONE] TODO: get_time_ms

[DONE] FIXME: stdlib_number test returns 402
if ((0.5).toFixed() !== "1")

[DONE] TODO: call_apply
- Change callFun return address? Currently expects IRInstr

[DONE] TODO: map_prop_name

[DONE] TODO: establish fourth milestone
- All benchmarks running?

------------------------------------------------------------------------------

[DONE] Third milestone: standard library initialization

[DONE] TODO: make_link, needed by commonjs lib
- Why is it needed? What uses it?
  - set_str
  - regexp
- Easier to just keep supporting this for now

[DONE] TODO: add test for ctor with less args than needed, test for undef

[DONE] FIXME: segfault on ./higgs --e "test()" programs/stdlib_map/stdlib_map.js
- try with --jit_dumpinfo
- trace instructions
- Fails in Map.prototype.set
- call with integer 1 for closure value
- Missing argument init was wrong for new and regular call

[DONE] TODO: support for return from new
- enable unit tests

[DONE] TODO: new/constructor support
- Implement using host function first

[DONE] Meeting:
- Objects, arrays, closures, argument object, floating-point
- Fixed various bugs
- Almost all of stdlib loading
- Most unit tests working
- Missing features: exceptions, GC
- Higgs init time comparable to before, with interpreter
- Compiling ~300KB of code to init
- Idea: can recompile inline caches (at Moz, inline caches are linked-lists)

[DONE] TODO: mod_f64, using fmod

[DONE] TODO: f64_to_str, f64_to_str_lng

[DONE] TODO: cos_f64, sin_f64, sqrt_f64, log_f64, exp_f64, mod_f64, ceil_f64, floor_f64
- template unary FP host fun? HostFPOp(fun)
- enable unit tests
import std.c.math;

[DONE] FIXME: bug in merge sort test?
- has to do with cycle resolution in moves.d?
- issue with regress/loop_swap too?

[DONE] FIXME: higgs init time is quite slow
- profile it
- how much faster if we don't load regexp lib?
- add options to log functions being compiled?
execHeap = new CodeBlock(EXEC_HEAP_INIT_SIZE, /*opts.jit_dumpasm*/true);
- Disabling ASM comments gives us a huge speedup

[DONE] FIXME: arg_obj test segfaults
make; ./higgs --jit_dumpinfo --e "print(test())" argobj.js
- ret 0 instruction from test() segfaults
- is it return with extra args that's defective?
  - pushing 8 slots, as expected
  - popping wrong number of values
  - argc is way off... 64-bit issue? no
- Popping wrong number of args... 7 instead of 8
- extra args computation in gen_ret was wrong

[DONE] FIXME: assertion failed in stdlib/number test

[DONE] TODO: try enabling stdlib/math.js
- comment out loading of other libs for now

[DONE] TODO: array element access

[DONE] TODO: work towards object property access
- gen_map_num_props
- gen_map_prop_idx

[PASS] TODO: implement wrapper for static function ops
- HostOp(alias op, alias fun)(...)
static if( i < T.length - 1 && is( r1 == void ) )
static assert( a1.length != 1 || !is( a1[0] == Variant ),

[DONE] TODO: try to optimize call logic. Can some operations use 32-bit opnds?
- Can we use a second scratch reg to compute extra args?
- Can now count on delegate for scratch regs

[DONE] TODO: use delegates for the branch generation function
- No context object if no variables captured
- remove instr argument

[DONE] TODO: reimplement test-then-if optimization
- Test needs to generate the branching directly
- If suppresses its own code generation

[DONE] TODO: eq_f64, ne_f64, lt_f64

[DONE] TODO: look into D traits for function pointers
- Not clear from traits page, ask on D forum

[DONE] TODO: ask on dconf about closure opts
- make thread: Memory usage of delegates
  - Will it allocate extra objects or context if no shared variables?
  - Are closures heap-allocated, or by value?

[DONE] TODO: support for div_i32
- Needed for int to string conversion
- enable corresponding tests

[DONE] TODO: get_str
- try enabling string concat tests, try in the REPL first
- template one arg instructions like this? not yet

[DONE] TODO: function to save special jit registers

[DONE] FIXME: fix as.printStr
- test with heapAlloc

[DONE] TODO: lea instruction encoding
- only need to support 64-bit version

[DONE] TODO: closure variable support
- needs heap_alloc

[DONE] TODO: get_word, get_type, make_value
- needed for closure cells

[DONE] TODO: heap_alloc

[DONE] TODO: blog
- specifics of incremental JIT
- progress
  - REPL, static calls, primitives, tests
- stress/discomfort of having to take many important design decisions at once
  - exploratory programming
- compiler architect may be a great career move
- conference invites (mloc.js, Web Directions Code)
    http://mloc-js.com/
    http://code13.webdirections.org/
- book invite, AOSA vol 4
    http://aosabook.org/en/index.html

[DONE] TODO: store op

[DONE] TODO: support for print(), useful for debugging
- Needs regular calls, string functions

[DONE] TODO: load, needed for print

[DONE] TODO: compileEntry, log function being compiled for --jit_dumpinfo

[DONE] TODO: $ir_get_arg, needed for print(), others

[DONE] TODO: log call block size in bytes
- 330 bytes

[DONE] FIXME: call version has branch code marked as inside of it!
- genBranch should do markEnd?

[DONE] FIXME: segfault on too many arguments

[DONE] FIXME: identity function doesn't get its argument
- seem to be pushing the right number of locals

[DONE] TODO: transition regular call and new stub to unique shared stubs
- separate compileEntry function
  - ast-to-ir
  - adjust topmost stack frame, add undef args
  - compile entry block
  - set entry block ptr
  - no stub patching
- remove handling of null block ptr
  - just have special EntryStub code fragment

[DONE] TODO: init numLocals, numParams before ast-to-ir

[DONE] FIXME: some instructions have no disassembly?
- lost our alignment somewhere?
  - when patching a stub?
- try disabling rewriting of comments, see if it fixes the issue
  - doesn't seem to fix the problem
- seems we often get a misalignment after "jmp rax"
- problem could be in the selection of comments for versions/fragments
- the code being printed is some unit function entry...
  - no matter what's being printed
  - it's the machine code that's wrong, not the comments?

[DONE] TODO: regular function calls
- Need to do AST->IR conversion
  - May need special kind of stub?
- Should also store code ptr on IRFunction
- Entry stub?
  - could have one regular call stub and one new call stub
  - check the IRFunction, do the AST->IR?
  - issue: num locals, clos local varies
  - this is an issue for the GC too? Not really?
  - stubs may have to be specific to the function
  - how much code are we talking? everything already spilled
- call needs to:
  - get IRFunction ptr from clos
  - get numArgs
  - loop, pushing extra undef params (if not enough args)
  - get numLocals, push space for locals
  - push RA (linked)
  - get entry version ptr, jump to it (not linked)
- If not a closure, need to throw an exception ***
  - Make sure all is spilled, call an interpreter function
  - Can mostly ignore this for now

[DONE] TODO: modify new_clos to generate entry stub

------------------------------------------------------------------------------

[DONE] Second milestone: load runtime, working REPL with --nostdlib
- No GC yet
- Still no reg alloc
- Support for runtime primitives

[DONE] TODO: $ir_print_str

[DONE] FIXME: !0 should produce true, not infinity
- same for 0 && 2
- phi node problem? All of these have phi nodes
- execMoves is unimplemented!

[DONE] TODO: port/fix execMoves

[DONE] TODO: basic phi node handling
- without reg alloc, everything on stack
- need to implement allocState

[DONE] TODO: combine allocMap + typeMap
- Use struct with bit field inside, enum?

[DONE] TODO: set_str

[DONE] TODO: --jit_dumpinfo, write the exec heap position / size
- Do we have stat counter for total number of stubs and number of versions?
- Should log all this at end of compile() invocations

[DONE] TODO: CodeBlock toString needs start and end offsets

[DONE] TODO: jit_dumpasm, print only compiled code
- CodeFragment.toString

[DONE] TODO: enable all working unit tests

[DONE] TODO: log when phi nodes are used

[DONE] TODO: not_i32

[DONE] TODO: left shift, right shift

[DONE] TODO: less-than comparison

[DONE] TODO: mod_i32

[DONE] FIXME: invalid offsets
linking fragment ref, offset=18446744073709549282
- Log what the reference is to
- Negative offsets

[DONE] TODO: more complete return support
- but not yet return from new
- start with plain return, no return from new

[DONE] TODO: support for call_prim
- retWordReg, retTypeReg
- Return BranchCode object

[DONE] TODO: getCtx(IRFunction fun, bool newCall)
- Add ctx equality to state comparison
- Problem: two generic contexts?
  - Examine getBlockVersion
  - When does the generic state get created? Can we create one with matching ctx?

[DONE] TODO: reimplement add_i32_ovf, etc.

[DONE] TODO: reimplement if_true

[DONE] TODO: jcc instructions using reflist... Need to template this

[DONE] TODO: add compiled fragments to fragList
- Add compiled versions and also branch code

[DONE] TODO: reimplement gen_jump

[DONE] TODO: For end of block encoding, may be able to just use a function pointer (not a closure)
- Function takes enum indicating target 0 next, 1 next or neither next
- Function does the encoding of necessary branches
- Creates version refs as appropriate
- For call, can do the RA push, then jump to call entry
- Should simplify things, expose the logic in the appropriate places!

[DONE] TODO: May want to have branch edge moves in their own "code fragment" objects
- More flexible, these then become movable
- More efficient
- Can handle unit call/return more elegantly
- For return, can place ret word/type in special registers
- Return address is return branch edge
- Return branch edge moves ret val into stack slot (or not)
Fragment
BranchCode
BlockVersion
VersionStub
VersionInst

[DONE] TODO: genBranchEdge could return a BranchCode object?
- Can call method genCode(as, predState) at end of block?
- For return, write special moves, then call genCode

[DONE] TODO: implement setWord, setType

[DONE] FIXME: when compiling stub, should not be creating new block version in list
- replace stub entry instead
- don't use getBlockVersion
- array replace function?

[DONE] TODO: support for add_i32_ovf
- sufficient to compile basic add lazily
- add simple unit test

[DONE] TODO: low-level int & FP instructions

[DONE] TODO: need support for loading f64 imm to XMM
- Could use move to r64, then movq?
- For now, special case for zeroing out?
- pxor xmm, xmm?
66 0F EF /r PXOR xmm1, xmm2/m128
- general case, can jump over an inline constant
  - need one constant for our usage!
- try implementing limited IPR?
  movq(XMM0, X86Opnd(64, RIP, 2))
  jmp8(8) ; 2 bytes long
  ...64-bit imm...
  ...code resumes...

[DONE] TODO: limited IP-relative addressing, RIP + offset
- Use bit fields to pack mem loc representation

[DONE] TODO: jmp8

[DONE] TODO: div_f64, needed for NaN

[DONE] TODO: new_clos instr

[DONE] TODO: make_map instr
- Can allocate the map at JIT time!

[DONE] TODO: assert minimal space before compiling block
- 1 << 18 bytes (256KB)

------------------------------------------------------------------------------

[DONE] First milestone: no interp, basic incremental codegen
- No inlining
- Stubs
- Bump write pos to allocate, no code compaction

[DONE] TODO: IsTypeOp + unit test

[DONE] TODO: direct jump, add new if test for this

[DONE] FIXME: stub code not getting generated
- compQueue not mutated properly?

[DONE] TODO: CodeBlock.label should add a comment

[DONE] TODO: CmpOp
- For first version, always use cmov to produce a boolean

[DONE] TODO: setOutType with constant Type value

[DONE] TODO: genBranch
- For now, just switch on test type, do jump if false

[DONE] TODO: define a constant for JMP_REL32_OPCODE

[DONE] TODO: where do we set codeLen?
- Need to mark the inner code end explicitly

[DONE] TODO: versionRefs, compQueue...
- Add to Interp object directly
- Assert compQueue empty when entering compile

[DONE] TODO: could we merge ASMBlock, ExecBlock, compile directly in the execHeap?
- bool exec, bool comments
- Threads: just acquire a lock
- What if we exceed the bounds of the exec heap?
  - Need to do an exec heap compaction
  - This could conceptually happen mid-codegen
  - Could overestimate the max size of instructions + moves? Not obvious?
    - Can h4xx it, fix threshold at 1MB
- How do we deal with branch moves?
  - Could do a simple, direct encoding of final branches
  - At the same time, give block version useful annotations
- get rid of BlockVersion.write

[DONE] TODO: X86Reg.opnd(size)

[DONE] TODO: think about branches at end of blocks
- Can specifying operands to test and targets be enough?
  - e.g.: ilt, ieq, fgt, 64-bit, overflow
  - direct jump
- Works for if-type branches, type tests
- Calls are handled separately
- Look at old jit ops

[DONE] TODO: movsd encoding
Enc(opnds=['xmm', 'xmm/m64'], prefix=[0xF2], opcode=[0x0F, 0x10], rexW=False),
Enc(opnds=['xmm/m64', 'xmm'], prefix=[0xF2], opcode=[0x0F, 0x11], rexW=False),

[DONE] TODO: try implementing set_global, get_global
- Seems we don't need register allocation for this
- Problem: there is no cached global property index
  - Need to get those at JIT time
- Can get rid of the cached idx on the instruction
  - Get rid of IRCachedIdx as a whole

[DONE] TODO: setOutType w/ reg arg

[DONE] FIXME: return doesn't deal with mem arg
- tmpReg not properly implemented in getWordOpnd

[DONE] FIXME: odd assertion error involving comment strings
- Happens inside writeBlock, while merging strings
- Seems assumeSorted fails
- execHeap is not cleared everytime

[DONE] TODO: look at add_i32
- Should we implement reg alloc now?

[DONE] TODO: patch stubs once compiled
- create external compileStub and compileUnit functions?
  - both call internal compile function, not extern (C)

[DONE] TODO: patch version refs, refList

[DONE] FIXME: return 1 unit test fails
- test more encodings
- fixed bug in push/pop encoding
- reading from interp object causes segfault
- found bug in encoding of mov r15, imm

[DONE] FIXME: duplicate ret asm string, missing comment string
- Something wrong in CodeBlock.toString?
  - dump all the strings to verify
  - strings are as presented, ret is there twice at the same position!
- Found bug in clear function

[DONE] TODO: --jit_dumpasm

[DONE] FIXME: segfault while compiling unit entry
- Bug in getWordOpnd

[DONE] TODO: make Interp compile/call unit functions

[DONE] TODO: return op generation for unit-level functions
- Also need entry generation for unit-level functions
  - static template flag to compile?

[DONE] TODO: basic implementation of getWordOpnd/getTypeOpnd
- Needed for return op, other ops

[DONE] TODO: initial genBranchEdge(edge, predState)

[DONE] TODO: stub generation
- stubs call the JIT with block and state object ptrs
- Need special class for stubs
call compile
jmp RAX

[DONE] TODO: begin sketching compile(block, state)
- Should start with all values always on the stack, no type info
- How do we deal with requests for other versions?
  - Compilation queue?
  - Finalize blocks into execHeap at the end?

[DONE] TODO: interp, add new fields
- execHeap
- blockVersions list
- map of blocks to versions

[DONE] TODO: xmm arith op encoding
- No immediates
- Some have L vs R encoding
- Some have two opnd sizes supported
- Do template but keep it limited
  - add, mul, sub, sqrt, ucomisd
  - writeXMM64

[DONE] TODO: shift encoding

[DONE] FIXME: crash bug in movsx test
- code causes crash
- bug in mov mem8, imm8 encoding

[DONE] TODO: movsx, movzx encoding

[DONE] TODO: think about how compilation starts in interpreter
- Setup call stack
- Create ctx for unit function
- Create state for entry block
- Call compile(bloc, state)
  - returns code ptr
- Call into entry block
- Call and return from unit functions can be special
  - Setup stack properly, use ret instr on return
- When stubs are hit, further compilation occurs

[DONE] TODO: idiv, not, inc, dec encoding
- Make template for this, writeRMUnary

[DONE] TODO: CodeBlock, specialize into ASMBlock and ExecBlock
- ASMBlock has auto-expansion

[DONE] TODO: sketch BlockVersion class in jit.d
- BlockVersion: block, state, startIdx
  - state at entry
- VersionStub: no length, instance ref
- VersionInst: branch descs, move code idxs
  - Final branches and associated moves
  - May need to be specific about what conditional branches are testing
  - Target BlockVersion objs

[DONE] TODO: imul encoding

[DONE] TODO: begin testing code execution

[DONE] TODO: sub encoding

[DONE] TODO: conditional jump, jcc encoding
- Template it based on jmp

[DONE] TODO: cmov encoding
- TODO: template with opcode?

[DONE] TODO: mov encoding

[DONE] TODO: support for labels in assembler
- Write code in the code block
- Write empty patchable gap for address
- Store label ref in a list in the assembler object
- Need linkage pass to match refs to labels in table

[DONE] TODO: should also have option to record assembly strings
- Maybe this should be at the code block level
- Allows carrying over when writing code block
- Store pairs of indices and strings
- Have some asmComment function that checks for jit_dumpasm
  - Should take mnem and args as params
  - Could have 4 versions for different arities (0,1,2,3)
    - Template that, yo
  - Should also disable if not in debug mode

[DONE] TODO: template encoding of add for sub/cmp/or/xor/etc

[DONE] TODO: begin testing instruction encodings
- Test with CodeBlock or with Assembler?
- Need assembler objects if we have labels
- Could test both kinds separately
- Start with CodeBlock only

[DONE] TODO: instruction encoding, use templated function?
- Can have templated fn with many template parameters
- The two arguments are the only actual parameters
  - One of the arguments may be "none"

[DONE] TODO: deny 32-bit base or index registers, for simplicity?
- Simplify mem opnd, use reg no only, smaller size

[DONE] TODO: X86Opnd struct with union inside
- Needs a special none value

[DONE] TODO: begin with simple instruction encodings in x86.d
- No intermediate structures for instrs, just encode directly
- First goal is basic system working, don't write all encodings now
  - But begin testing early
- Lower-level encoding functions should work with CodeBlock objects
- Some op like move, cmp, jz should work on CodeBlock
  - But can be aliased for Assembler (possibly with an easy macro!)
- Some ops only fit in innerCode, should apply to Assembler only
nop(CodeBlock cb, size_t length = 1)
jmp(CodeBlock cb, Label label)

[DONE] TODO: x86 opnds
- Want to avoid allocating big objects for mem opnds, etc.
- Want operand structs
- Could use regno values in mem opnds to avoid infinite rec
- Could maybe have a big X86Opnd union for when needed?
  - Or just one big struct implementing it all?
  - Multiple structs are probably more expressive, more specific

[DONE] TODO: sketch CodeGenState, CodeGenCtx in jit/jit.d
- CodeGenState has ctx object pointer
- CodeGenCtx should have:
  - IRFunction, 
  - num extra locals, 
  - parent context (for inlining)
  - inlineSite (call site, if inlined)

[DONE] TODO: CodeBlock class

[DONE] TODO: comment out assembler tests, remove encodings

[DONE] TODO: compute fun liveness info in ast-to-IR

[DONE] TODO: remove JIT entry point, block exec count from IR

[DONE] TODO: comment out JIT code
- Comment out contents of jit.d, ops.d

[DONE] TODO: comment out interpreter ops
- Remove superfluous ops

[DONE] TODO: comment out interpreter unit tests

[DONE] Meeting:
- Conference
- Internships
- Incremental code gen
- Clever stack alloc & inlining

------------------------------------------------------------------------------

[DONE] TODO: unit test that checks object == and === equality after extension
- Push to master once done

[DONE] TODO: unit test that extends global object through indirect pointer
- globalObj = this; ...
- Loop with property names to 5000
- Once extended, try setting global prop, reading global prop

[DONE] FIXME: delete as property name not supported
- Special case of . member operator
- Add parser test
- Test map
- Does Tachyon have map unit tests?
- Push to master

[DONE] TODO: add map.js to Higgs stdlib
- Impact on make test time?
- Make more ES6 conformant

[DONE] TODO: think about lazy code gen, make new codument

[DONE] TODO: custom D assert handler
- Even more useful if no more interpreter
void setAssertHandler(errorHandlerType h);
alias AssertHandler = void function(string file, size_t line, string msg) nothrow;
throw new AssertError( msg, file, line );

[DONE] TODO: ask StackOverflow about 4GB executable alloc
- Want to guarantee 32 bit relative jumps always work
- Does any OS allocate the pages you don't touch?
=> yes, probably safe, but not clear that this is necessarily what we want
    how will our memory GC work?
=> limited to 2GB machine code, not that great anyways?
=> probably want to prefer 32-bit offset, but support 64-bit if needed?

[DONE] Monday meeting:
- Higgs roadmap
- Benchmarks using arrays
- Unifying theme for thesis
- Internship possibilities for the summer *****

[DONE] TODO: look at benchmarks using arrays
- How are the arrays used? Do we always loop over all elements
- Submethods mutating elements? ***
- SunSpider:
    spectral norm might work
    3d-cube, many matrix/vector ops, most not in a convenient form
        may be able to tag on creation, however
    3d-raytrace, has 3D vectors, but loops pre-unrolled
        could also test on creation and write
    fannkuch, integer arrays, but no clear "i < length"
    nsieve, boolean array, same problem
    cordic, float array, same problem
    crypto benchs use byte arrays
    string-base64 also has arrays of ints
- V8:
    crypto uses arrays with constants instead of .length for size
    navier-stokes, uses width, height which aren't array length
- Many benchmarks use arrays of integers and floats, especially in SunSpider
- Sensible way is to test when writing to array, not when reading

[DONE] TODO: think about unifying theme for thesis
- Lazy compilation?
- Versioning?
- Dynamic compilation? Dynamic languages need dynamic compilers
  - Versioning and laziness fit under this umbrella
- Dynamic, delayed compilation for better performances
- Many ways to be dynamic
- Argument why this is good

[DONE] Group meeting:
- Higgs refactorings
- Map system on the host side
- Created a dev branch
- Higgs roadmap

[DONE] TODO: new document, Higgs roadmap
- Lazy JIT plans
- Local profiling
- Inlining, should be more aggressive in hot code
- Type representation
- Interprocedural JIT
- Lazy prop? How to make this practical

[DONE] TODO: make print accept var arg, use $argc

[DONE] TODO: re-run ./benchmark after map introduction (on desktop)
is_i32: 4925933
is_const: 73248
exec time (ms): 1187
comp time (ms): 180
interp cycles: 535948
code size (bytes): 90032
is_rawptr: 28
call bailouts: 6
is_i64: 1
type tests: 7825131
unjit instrs: 55799
ret bailouts: 5
is_refptr: 297776
is_f64: 14666

[DONE] TODO: shootout/hash2, class capacity exceeded, should work now

[DONE] TODO: create dev-maxime branch

[DONE] TODO: rename ClassMap to ObjMap?

[DONE] FIXME: obj_get_map, need load_mapptr

[DONE] FIXME: segmentation fault
instr: ret $2 ($rt_arrtbl_alloc(14FF))
instr: $0 = map_num_props $8 ($rt_newArr(2B3C))
Segmentation fault (core dumped)

[DONE] FIXME: interp.interp.RunError: call to non-function
RegExp(AB62) ("stdlib/regexp.js"@864:1)
- Probably method lookup failing?

[DONE] TODO: GC must scan ctor map in closures

[DONE] TODO: new ctor map, set at new_clos time? Should be the same for all "new" operators
- Just lazily create in new

[DONE] TODO: $rt_getPropEnum
- Need way to get prop names, null if none?
$rt_class_get_prop_name => $ir_map_prop_name

[DONE] TODO: $rt_getPropIdx, IR instr should return false if not found

[DONE] TODO: $rt_class_get_num_props(classPtr) => $ir_map_num_props?

[DONE] TODO: look at link creation in ir/ast.d

[DONE] TODO: MAKE_CLASS, minNumProps, numRsvProps

[DONE] TODO: gc, when scanning IR, scan IRMapPtr, visitMap!

[DONE] TODO: interp/ops, make MAKE_CLOS, newArr, newObj use IRMapPtr instead of IRLinkIdx

[DONE] TODO: GC, when traversing object, visit map ptr, visitMap

[DONE] TODO: rework map creation in interp.d for newObj, global obj
- Add ref to mapRefs
- newMap(Interp interp)? getMap?

[DONE] TODO: remove map layout

[DONE] TODO: map accessor instructions
- Mostly just getPropIdx for now?

[DONE] TODO: gc support for maps
- mapRefs, liveMaps

[DONE] TODO: run ./benchmark before refactoring (desktop times)
is_i32: 4981024
is_const: 75589
exec time (ms): 955
comp time (ms): 220
interp cycles: 624630
code size (bytes): 102622
is_rawptr: 29
call bailouts: 6
is_i64: 1
type tests: 7884795
unjit instrs: 6746
ret bailouts: 5
is_refptr: 299946
is_f64: 14909

[DONE] TODO: MAKE_MAP instr
- Make classes host/VM objects
- CLASSPTR type tag
- needs caching, IRClassPtr

[DONE] TODO: implement class map

[DONE] TODO: can we eliminate setTarget with branch desc argument, have only block arg?

[DONE] TODO: IR, attach branch descs to branch instructions instead of pred blocks?
- examine use cases
  - grep -R "\.pred" .
- might need to rework remInstr, remBlock?

[DONE] TODO: remove type prop from master branch

[DONE] TODO: pull changes from cc2014 branch

[DONE] TODO: add music.js to lib/

------------------------------------------------------------------------------

[DONE] Oct 11th: CC Paper Submission Deadline
- 20 page limit, LNCS format

[DONE] TODO: create cc2014 branch on github
- put inlining limit very high, 50
- reduce min call frac

[DONE] TODO: typeProp improves upon versioning results on 3d-cube, why?
- Identify smaller benchmark where typeProp catches cases
./higgs --stats --jit_maxvers=50 --jit_typeprop
- bitops-nsieve-bits also
- beats us on phi nodes *** why???
Flow into self might be tricky?
- We can enter mid-loop... Have no type info
- Very little difference when enabling type prop over versioning in practice

------------------------------------------------------------------------------

[DONE] TODO: test --jit_typeprop with ./benchmark.py
./benchmark.py --higgs_cmd="./higgs --stats --jit_maxvers=0 --jit_typeprop"
- Works, successfully reduces type tests

[DONE] TODO: use typeMap in IsTypeOp

[PASS] FIXME: programs/sunspider/crypto-aes
- Nondeterministic behavior, decryptedText.length varies between runs
- Does it work with --jit_disable? Same number of interp cycles, same string length?
- Nope!
- Problem with interpreter u16 load/store semantics?
  - Not load, check if store changes value
  - Store: value properly truncated, but u32 always different
- Why are the int32 values not always the same...
- Nondeterminism comes from usage of date, but length should be the same as V8...
- Faulty regexp implementation may be at fault, skip for now

[DONE] TODO: test typeProp with ./benchmark.py

[DONE] TODO: store typeMap on CodeGenCtx

[DONE] TODO: examine typeProp code, do transfer functions all make sense?
- Found one bug

[DONE] TODO: email Marc, notes:
- Added type test breakout by type
- Tried tweaking inlining heuristics to further reduce type tests, not very successful
- Began implementing intraprocedural representation analysis, based on SCCP
- Will add command-line flag to enable analysis

[DONE] TODO: test --jit_typeprop
./benchmark.py --higgs_cmd="./higgs --stats --jit_typeprop"
./benchmark.py --higgs_cmd="./higgs --stats --jit_maxvers=0 --jit_typeprop"

[DONE] TODO: add command-line option to enable type prop, --jit_typeprop

[DONE] TODO: complete type prop implementation

[DONE] TODO: document csv module, example

[DONE] TODO: begin work on intraprocedural representation analysis (SCCP)
- ir/typeprop.d
- Same type model as backend
- Must be able to gain info from type tests
- Fixed-point

[DONE] TODO: read_i8, read_i16, notify Tom
- Ask to use load_u32 for load_i32

[DONE] TODO: try inlining all the adds/subs/muls first
- 3d-raytrace is very sensitive to the inlining of arithmetic primitives
- Do it one-level only: make list of adds/subs/muls in CFG, inline them
- Does this reduce the number of type tests? Check effect with ./benchmark
- Before, growth factor 30x:
    is_i32: 2141245
    is_const: 20976
    exec time (ms): 1465
    comp time (ms): 402
    interp cycles: 1267749
    code size (bytes): 138314
    is_rawptr: 35
    call bailouts: 7
    is_i64: 1
    type tests: 3717303
    unjit instrs: 5992
    ret bailouts: 8
    is_refptr: 291458
    is_f64: 10210
- After, growth factor 30x:
    is_i32: 2136726
    is_const: 20977
    exec time (ms): 1485
    comp time (ms): 425
    interp cycles: 1270943
    code size (bytes): 139407
    is_rawptr: 35
    call bailouts: 7
    is_i64: 1
    type tests: 3712645
    unjit instrs: 5997
    ret bailouts: 8
    is_refptr: 291435
    is_f64: 10199
- Doesn't do much!

[DONE] TODO: try smaller growth factor for just primitives, eg: 3x
- Still many type tests to eliminate
- Unfortunately doesn't help at all

[DONE] TODO: copy over Tachyon SCCP code into ir/typeprop.d, create bare module

[DONE] TODO: breakout of specific kinds of type tests with counts

[DONE] TODO: try scrapping min call frac heuristic
- See effect on global type tests, code size, exec time
- Before, budget 3x
    exec time (ms): 621
    comp time (ms): 133
    interp cycles: 675989
    code size (bytes): 108567
    call bailouts: 0
    type tests: 7957747
    unjit instrs: 0
    ret bailouts: 0
- Before, budget 40x
    exec time (ms): 880
    comp time (ms): 235
    interp cycles: 1270519
    code size (bytes): 142653
    call bailouts: 0
    type tests: 3540466
    unjit instrs: 5998
    ret bailouts: 0
- After, budget 3x, frac 50
    exec time (ms): 681
    comp time (ms): 142
    interp cycles: 662441
    code size (bytes): 109442
    call bailouts: 0
    type tests: 9063187
    unjit instrs: 7688
    ret bailouts: 0
- After, budget 10x, frac 50
    exec time (ms): 825
    comp time (ms): 249
    interp cycles: 879796
    code size (bytes): 133343
    call bailouts: 0
    type tests: 5866077
    unjit instrs: 8144
    ret bailouts: 0
- After, budget 40x, frac 50
    exec time (ms): 1091
    comp time (ms): 345
    interp cycles: 1240329
    code size (bytes): 153116
    call bailouts: 0
    type tests: 3693675
    unjit instrs: 6118
    ret bailouts: 0

[DONE] Meeting notes:
sort log_tests_3d_raytrace.txt | uniq -c | sort -n
- FP comparisons improved based on GCC
- Added CSV output to benchmarking script
  - For paper, command-line tools, latex csv package
- Discuss specific metrics to gather
  - currently: 
    - total generated code size
    - JIT compilation time (*JIT only*)
    - Total execution time including compilation
    - Number of type tests executed by the JIT
- Toutes les statistiques (incluant le temps d'exécution) devraient se faire
  mesurer lorsque le code s'est "stabilisé" (plus de nouvelles versions de BB).
  - Difficile a faire, invalidation de code pendant execution, somewhat incremental
- Dans l'article on pourra compléter avec des statistiques plus globales (incluant
  le temps de compilation, le temps passé dans l'interprète, etc).
  - I have usec counter, but lots of context-switching happens, won't be fully precise?
  - Could design timer mechanism based on state machine, events, count time in each state?
  - Could try using CPU cycle counter (but will include *some* OS context-switching noise
- Il ne faut pas perdre de vue qu'on doit découpler autant que possible l'étude
  du versionnement de BB de son implantation dans Higgs
  - Optimal case, compilation time is irrelevant?

[DONE] TODO: log JITTed type tests executed, examine what happens in 3d-raytrace
- needs inlining budget of ~20X to eliminate most type tests...
- can we annotate functions? how can we help this?
- can do JIT trace, see where types tested come from
- with 3x budget:
    3d-raytrace : is_i32 tests in rt_add and rt_lt
    3d-cube     : is_i32, is_f64 in add, lt, ge, some inlined in DrawLine
    earley-boyer: se, getProp, setProp, all uninlined
    still many calls to uninlined primitives
- with 40x budget: 
    3d-raytrace : is_i32, is_f64 Triangle.prototype.intersect, many getProp, still some rt_lt, rt_ns
    3d-cube     : almost all is_i32 and is_f64 in drawline. Why are these not all eliminated???
    earley-boyer: many in getProp, ns, some inlined

[DONE] TODO: benchmarking script, add cmd line options for higgs CMD, csv out file
- Keep default command
- Does Python have some option parsing module?

[DONE] TODO: look into CSV command-line tools
- transpose, concat, etc
- use python CSV package, program util fns

[DONE] TODO: look into CSV to latex tool
\documentclass{article}
\usepackage{csvsimple}
\begin{document}
\csvautotabular{scientists.csv}
\end{document}

[DONE] TODO: benchmarking script, generate CSV output

[DONE] TODO: get updated stats
exec time (ms): 1004
comp time (ms): 234
interp cycles: 675941
code size (bytes): 108613
call bailouts: 0
type tests: 7958803
unjit instrs: 0
ret bailouts: 0

[DONE] FIXME: growth factor issue, functions grow at every invalidation

[DONE] TODO: use "growth factor" based on initial size for inlining budget
- Special provision for small functions
- Allow 3x, shrinkage after peephole

[DONE] TODO: sort call sites by exec frequency for inlining
- Go through call sites, find most executed eligible call site
  - implement in separate function
  - could check caller and callee size at the same time
- Eliminates need for current min frequency heuristic
- Log performance before and after
- Keep minimum call threshold for inlining, useful for primitives

[DONE] TODO: threshold on block stubs before immediately invalidating
- Might save compilation time, allow for more useful profiling

[DONE] TODO: get mean exec times and type tests
exec time (ms): 1146
comp time (ms): 175
interp cycles: 801596
code size (bytes): 93926
call bailouts: 0
type tests: 7174455
unjit instrs: 7948
ret bailouts: 0

[DONE] TODO: benchmark script, geo mean of type tests, cut out decimals

[DONE] TODO: benchmarking script, display mean times (exec time (ms))

[DONE] TODO: stats, shorten names

[DONE] TODO: examine inlining decisions in bitwise-and, run with --nostdlib
- Way too many type tests!
- purportedly inlines rt_lt, rt_and, rt_add
- Need to look at ASM output
- The problem is that we're operating on global values!

[DONE] TODO: peephole opt for if_true of constant

[DONE] FIXME: 3d-raytrace segfaults with maxvers=0
./higgs --jit_maxvers=0 --jit_dumpinfo --stats programs/sunspider/3d-raytrace.js
- Crashes during GC, invalid ref?
  - Forwarding clearly integer or const value

[DONE] TODO: test nsieve-bits, 3d-cube, 3d-raytrace with maxvers=0

[DONE] FIXME: segfault with maxvers=1 on bitwise-and
./higgs --jit_maxvers=1 --stats programs/sunspider/bitops-bitwise-and.js
- crashes somewhere in stdlib?
entering fn: $rt_getPropObj(2D2F) (for_test(330C))
Segmentation fault (core dumped)
num blocks: 20
num versions: 21
compiling function $rt_getPropObj(2D2F)
compiling block: entry(3305) (execCount=252)
compiling block: for_test(330C) (execCount=801)
block cap hit: 1
compiling block: for_body(330D) (execCount=801)
entering fn: $rt_getPropObj(2D2F) (for_test(330C))
for_test(330C) ($rt_getPropObj(2D2F))
if_true true => for_body(330D), for_exit(330F)
for_body(330D) ($rt_getPropObj(2D2F))
$2 = call_prim "$rt_obj_get_next", <fun:$rt_obj_get_next(12F8)>, $1 => call_cont(331F)
entry(336D) ($rt_obj_get_next(12F8))
$0 = load_refptr $5, 0
Segmentation fault (core dumped)
Note: we're entering getPropObj mid-loop, at for_test, and the block cap is hit...
- Take a look at ASM dump!
- When we jump from the exported entry point, we don't load anything into r10
- Probably because we don't treat entry points like block transitions ****

[DONE] TODO: implement cap on number of block versions
- Add command-line options, jit_maxvers=n
- If we request things like known phi types, will get mismatch
  - Once we reach the vers limit, compile general version, will match all
- General vers can have custom regs, but no known types and values
  - Strip pred map of known types and values

[DONE] FIXME: issue, function entry contexts have no locals, will give perfect match score?
- Should have penalty if pred map has more entries than succ map?
- Or maybe do another scan for pred maps, check for missing info in succ

[DONE] TODO: CodeGenState.diff(that), distance function
- returns size_t, size_t.max if incompatible, 0 if perfect match
- Sums up penalties

[DONE] TODO: implement get_link instruction in JIT
- pre unjitted ops, 3d-raytrace: 59713, 3d-cube: 104491

[DONE] TODO: implement floating-point comparison instructions
- 3d-raytrace, 3d-cube dominated by FP comparisons
- use UCOMISD instruction
- Pre-opt times, 3d-cube: 1796ms, 3d-raytrace: 2193ms
- Time not really improved

[DONE] TODO: genBoolOut

[DONE] TODO: release target with no asserts for performance testing
- the -release flag disables assertions

[DONE] FIXME: 3d-cube segfaults with lt_f64
- Do we need to use JB, JA, etc? with UCOMISD?

[DONE] TODO: get_arr_proto JIT instr

------------------------------------------------------------------------------

Goal: perf gains on loop increment microbenchmark 

[DONE] FIXME: earley-boyer segfaults when run on its own
$40 = add_i32 $18, 1
jump => arg_test(18645)
$0 = lt_i32 $18, $92
$19 = get_arg $18
Segmentation fault
sc_list(13F29)
0
sc_list(13F29)
139998753980417

[DONE] FIXME: JIT bug wrt call_prim, crash on stdlib init

[DONE] TODO: optimize calling primitives by name
- Time improvement on all benchmarks, code size reduced
- Number of type tests not always reduced

[DONE] TODO: Record new stats for 3d-cube, 3d-raytrace, earley-boyer

3d-cube:
total execution time (ms): 1948
total compilation time (ms): 563
machine code generated (bytes): 240666
type tests executed: 8724951
unjitted instructions executed: 346907
call bailouts executed: 0
return bailouts executed: 2626
interpreter cycles executed: 1569272

3d-raytrace:
total execution time (ms): 2844
total compilation time (ms): 968
machine code generated (bytes): 405845
type tests executed: 23950271
unjitted instructions executed: 192498
call bailouts executed: 0
return bailouts executed: 2544
interpreter cycles executed: 1106456

earley-boyer:
total execution time (ms): 5775
total compilation time (ms): 822
machine code generated (bytes): 354933
type tests executed: 24255101
unjitted instructions executed: 473302
call bailouts executed: 4143
return bailouts executed: 266451
interpreter cycles executed: 3638773

[DONE] TODO: add Marc's microbenchmark to repo
programs/jit/loop_decr_sum.js

[DONE] TODO: blog about inlining
- perf
- basic heuristics
- making inlining more selective
- many bugs in 300 lines of code
- testing with interpreter only
  - interpreter is robust, easier to debug
- benchmark loop incr to 500M with and without inlining

[DONE] TODO: phi of phi peephole opt
- pred has phi and then jump, succ has one phi which uses our phi
- make our incoming jump to succ, pass phi arguments directly
- big incr down to 3.2s, 409 bytes

[DONE] TODO: Redundant jump peephole
- Block ends in a jump, successor has no phi nodes, successor has only one incoming
- Might enable further phi elimination. 7 phis before. 7 after, but some opts!
- big incr down to 4.3s, 412 bytes

[DONE] FIXME:
mov rbp, [qword r14 + 200];             49 8B AE C8 00 00 00
mov [byte r13 + 23], 0;                 41 C6 45 17 00
mov [qword r14 + 184], 0;               49 C7 86 B8 00 00 00 00 00 00 00
Don't need to write the value 0 if we just wrote a non-pointer type tag
- Measure big_incr perf before and after
    5.9s    411 bytes
    5.1s    462 bytes

[DONE] TODO: add asm comment with function name for asm dump

[DONE] Meeting notes:
- Fixed many bugs, system now much more stable
- Inlining increases compilation time, but decreases execution time significantly
- Made inlining more selective
- Implemented static calls, significant performance gains
- Implemented propagation of known types through phi nodes
- Implemented OSR for top of stack functions mid-loop execution
- Enabled peephole opts mid-loop execution
- Tried loop to 2B, decreased type tests from 4B down to 1

[DONE] TODO: enable peephole opts mid-function?
- Need current target and liveness info
- Don't remove the current block (assert delBlock doesn't do this)
- Don't remove live phis or instrs (just skip?)
optIR(fun, IRBlock target)
- Don't delete the current target block
- Can't replace an instruction that's live by a value that's not live

[DONE] TODO: look at IR from big_incr, can we eliminate phi nodes easily?
- 7 phi nodes in total
- several possible improvements, worth looking into

[DONE] TODO: don't inline when compiling primitives? No!
- will make their compilation faster
- should result in better inlining overall
- do we have an isPrimitive, isRuntime test?
  - add method to IRFunction?
- What's the difference in compilation time?
- Performance is worse on every benchmark, even though comp time is smaller

[DONE] TODO: propagate types through phi nodes
- Could save type byte moves, generate better code in loop microbenchmark
- Reduced code size, reduced type tests on benchmarks
- Not much type test reduction on some benchmarks
  - Possibly, unjitted instructions are causing spills
- One type test executed in big incr (mid-loop entry), down from 4B

3d-cube:
total execution time (ms): 2223
total compilation time (ms): 599
machine code generated (bytes): 253236
type tests executed: 8998583
unjitted instructions executed: 344956
call bailouts executed: 0
return bailouts executed: 2426
interpreter cycles executed: 1820808

3d-raytrace:
total execution time (ms): 3052
total compilation time (ms): 909
machine code generated (bytes): 386667
type tests executed: 31909720
unjitted instructions executed: 190284
call bailouts executed: 0
return bailouts executed: 2494
interpreter cycles executed: 1310769

earley-boyer:
total execution time (ms): 6509
total compilation time (ms): 863
machine code generated (bytes): 362126
type tests executed: 32377182
unjitted instructions executed: 470606
call bailouts executed: 3725
return bailouts executed: 266251
interpreter cycles executed: 3885102

[DONE] TODO: modify IsTypeOp comparison + branch to add info to context?
- Loop microbenchmark does is_i32 twice, once for lt, once for add
- Could save 6 instructions in loop benchmark
- Pre-opt exec time : 8.45s
- Post-opt exec time: 6.78s
- Less type tests in 3d-cube and 3d-raytrace, but more code, slightly slower...

[DONE] TODO: look at code for the for loop test
- write this code in a JS file, programs/jit/big_incr_loop.js
time ./higgs --nostdlib --jit_dumpinfo --jit_dumpasm programs/jit/loop_big_incr.js
- phi nodes make optimization difficult... Should look at IR, try to enable peephole opts mid-exec?
- not passing type info through phi nodes, problematic for loop opt

[DONE] TODO: add comments for phi node moves... Hard to decipher as is

[DONE] FIXME: dumpir fails, segfault

[DONE] TODO: --jit_dumpir

[DONE] TODO: ASMInstr.nextNC?
- Modify peephole to ignore comments

[DONE] TODO: make inlining take advantage of static calls
- avoid placing conditional block when inlining call_prim

[DONE] TODO: implement call_prim in JIT
- funOnStack segfaults...
- only one call_prim occurs, to rt_lt, corrupts frame

[DONE] TODO: implement static calls for runtime primitives
- call_prim "str" ptr, cached IRFunPtr instruction
  - check that the function has no closure variables
- modify runtime call generation in ir/ast
  - call with IRFunPtr directly, no closure object

[DONE] TODO: optimize init loops in layout.js, use lt_i32, add_i32
- benchmark
- improves times of both 3d-cube and 3d-raytrace

[DONE] TODO: in collectFun, nullify instruction args, remove uses
- See if mem usage is improved, maybe a bit

[DONE] FIXME: sunspider/3d-cube segfaults
- Crashes just after rewriting the frame for MMulti
$5 = heap_alloc $23
$6 = get_global "$rt_arrtbl_set_cap", <idx:164>
$7 = get_global_obj
if_eq_fun $6, <fun:$rt_arrtbl_set_cap(1611)> => entry(100C2), call_reg(100CA)
$0 = get_global "$rt_arrtbl_ofs_cap", <idx:154>
$1 = get_global_obj
$27 = call $0, $1, $5 => call_cont(100C6)
ret 12
store_u32 $5, $27, $109
The offset is correct
The pointer is invalid
$5 gets corrupted?
- Bug in JIT heap_alloc implementation

[DONE] FIXME: jit crashes after inlining 
entering fn: $rt_obj_set_type(1301) (entry(3BD9))
- Store offset in store instruction is corrupted
- Need to zero-extend the offset

[DONE] FIXME: rework inlining to create return phi in special call merge block
Creating a return phi in a loop header is problematic. Can't know what the
initialization conditions should be for blocks that already have incoming branches

[DONE] FIXME: jit/jit.d(1186): no reg mapping for instr:
$26 = load_refptr $177, $52 (no uses)
./higgs --e "test()" --jit_dumpinfo programs/gc/graph.js
- peephole currently disabled when doing mid-execution OSR

[DONE] FIXME: top-level OSR faults after jit_inlining2
- op_set_str fails with refptr out of heap, odd!
  - possibly, a function was GCd, its link table entries collected?
- Possibly need to be careful when collecting link table entries
  - Should make sure they have no uses before removing them

[DONE] TODO: make load throw proper JS exception when failing to load file
- Test in interpreter
- Add test for this

[DONE] FIXME: top-level OSR segfaults 
- Could try again disabling JIT, letting interp run, problems will be more obvious
- ops.d(389): invalid operand 2 type in op "auto r = x * y;" (int32)
  - Log function where this occurs
- Phi value is not rewritten, skipped as dead
- Only 4 values written, none overwritten
- Log the values we're rewriting, to see if they make any sense
  - Values appear sensible
- PROBLEM: when at target, we already made the jump, we're *past* the phi nodes
  - Must check liveness after the phi nodes
- Still have an issue in 3d-raytrace
  rewriting frame for Array(5EE4) at for_test(E893)
  - Newly created array value is not rewritten
  - Array value not marked live after first block instr?
The $rt_newArr call was inlined
$20 = phi [call_reg(120B1):0 => $51, call_cont(120AE):0 => $50]
$20 is used in the loop body
$20 is returned
But somehow we don't see $20 as live at the for_test block
Do we even query for $20? Probably not... $20 was live before the
transformation, but isn't anymore!
Still a problem... We've created a phi node for the array (return phi), but
this phi node was not executed because it didn't exist!
Would need to check, for live values being rewritten, which ones are inputs to
phi nodes from our block, and the phi node wasn't rewritten (is new)
- Catches the case where we have a new phi node
- Idea is: I have a value that is live, does it go into some phi node that is
  also live here?
- Try this and see if it works in practice...
Do we actually want liveness info from before inlining? ***
Could we be in some situation where some phi node needed to have been executed
way back, because of some other inlining? The value was replaced by a phi node? ***
- Seems like we could
- Can detect what phi nodes are newly live, see which of their inputs were live previously
  - If multiple inputs were previously live???
  - In the case of inlining, might be impossible that multiple inputs were previously live,
    because the inlined case didn't exist
- store mapping of call sites to ret phi nodes, process phi nodes based on
post-inlining liveness info

[DONE] FIXME: inlining should not create return phi if there are no uses of the call site

[DONE] TODO: implement top-level OSR mid-function
- Save current stack frame into temp arrays
- Redo liveness info if necessary
- Pay attention to liveness and IP when doing peephole
  - For first version, probably shouldn't do peephole in this case

[DONE] TODO: IRBlock.moveInstr(dst)
- Want to maintain instruction identity when possible
- Stack frame translation post inlining will be problematic otherwise
- remove/unlink from current block
- add/relink in new block
  - update instr.block
- if branch, change descs to point from current block, replace old block in preds

[DONE] FIXME: sunspider/string-base64, jit/jit.d(1073): no reg mapping for instr:
$25 = and_i32 $1, -8
- Is this instr not used, is it from the wrong function?

[DONE] TODO: revise Higgs page on pointersgonewild
- add new supported benchs
- remove runtime redefinable prims as language feature

[DONE] TODO: IRValue.addUse if use is dstval, check that from same fn
- Put in assert or debug block

[DONE] TODO: enable JIT pathos test

[DONE] TODO: alloc state cleanup code
- After each instr, should check if its uses are now dead, if so, remove all
type and alloc info. For branches, should pass branch instr to the 
genBranchEdge function, this function should cleanup any uses of the
branch instruction itself.
- cleanup fn should just remove output type of instrs if immediately dead ***
- May want to add liveAtEntry and other helpful functions to liveness info class.

Meeting notes:
- Inlining bugs fixed, now fully working with JIT
- Found some language shootout benchmarks
- With inlining, compilation time is much longer, but benchmarks still faster
- More selective inlining, less useless inlinings
  - Faster compile time, less machine code generated, better execution time
- Pathological case, now we inline more useful code, but seem to get exponential blowup
- Probably need block version cap

[PASS] FIXME: function: safe_add(EF0C)
machine code bytes: 2798357
num locals: 108
num blocks: 106
num versions: 35294
- Doesn't even contain a loop, unclear why so many versions
  - Might have a string op in there?
  - No for_ blocks or obvious loop blocks
- In less bloated case, 10 versions of call_cont(FF89)
  - Are these legitimately different? Probably so
- Try to design a pathological case? Add of add of add...?

[DONE] TODO: make inlining more selective
- Don't inline calls with relatively small execution frequency
- Favor inlining of more likely calls
- Log data first to get an idea of call site ratios when inlining
  - Scheme seems to very much make sense
  - Place threshold at 1/3?
  - const CALL_MIN_FRAC = 3
- 3d-cube (pre)
    total execution time (ms): 2551
    total compilation time (ms): 737
    machine code generated (bytes): 338787
- 3d-raytrace (pre)
    total execution time (ms): 3839
    total compilation time (ms): 1230
    machine code generated (bytes): 571490
- Small but significant improvement on all factors

[DONE] TODO: handling of parsing new without parens
- Should enable 2 shootout benchmarks

[DONE] FIXME: inline test is wrong
- not testing the type of the callee value
- not testing that it's a function object
- should make special callee check comparison?
  - problem is, need multiple comparisons
- if_eq_fun <clos> <IRFunPtr>

[DONE] FIXME:
Tom: try importing the stdio lib
Tom: interp/ops.d(626): ref ptr not in from space in load op

[DONE] TODO: add shootout benchmarks to tests
- set arguments[0] before running each one

[DONE] FIXME: unit function arguments handling
- arguments should refer to the global variable, not the arguments object

[DONE] FIXME: regular JIT call doesn't check that callee is a function
- enable jit_call_exc test
- try to pass test with --jit_noinline first

[DONE] TODO: make JIT regression test that catches exceptions, change callee
- call instr should throw an exception if the callee is not valid

[DONE] TODO: re-enable IR opts after inlining

[DONE] FIXME: inlining bug, we replace uses of the call by uses of a phi node in
call_ret. This is incorrect. Must take the value of the call from call_reg
into account.
- Add the ret phi node to call_cont directly, as before.
- Add a value to ret phi from call_reg as well (the new call site).
- Add new phi arguments at inlined rets to *all phis*
  - if arg was call site, replace by ret value
- Need to do replacement of call site uses manually before inlining?
  - skip phis in the call cont block?
  - could replace all, then go over call con't block and replace by new call instr?
- There may be existing preds to the call_cont
  - ret phi should have incoming values for these too

[DONE] TODO: basic const prop for mul_i32
$2 = mul_i32 1, $10
$0 = mul_i32 2, 6
- inlining makes opportunities appear

[DONE] TODO: write adversarial JIT test where inlined call gets changed, new call
returns something different

[DONE] FIXME: 
sunspider/crypto-md5
global property "error" is not defined
programs_sunspider_crypto_md5_js(23C306) ("programs/sunspider/crypto-md5.js"@1:1)
- no GC
- make regression test
- str concat seems to be broken
  - try making JIT strcat test? replicates the problem
- something in strcat is broken (by the JIT) after inlining?
  - first bytes written are zeros
- We compile theAdd, and then our loop fails to execute... i remains undefined
  - Maybe it was never initialized to zero? Set to undef on some path?
- Still have bug in inlineCall wrt phi nodes in call cont block

[DONE] FIXME: Inlining, a stub is produced for call_ret... Give call_ret the same
execCount as the call continuation
- function gets invalidated every time a call_ret is hit!

[DONE] FIXME: assembler.d(395): invalid instruction: imul r10d, 0;
- Inlining now working with interpreter only

[DONE] TODO: in debug mode, try encoding instructions immediately when added to assembler
- X86Instr.isValid()

[DONE] FIXME: inlining causes GC crash?
./higgs --e "test()" programs/gc/strcat.js
visiting frame for: $rt_str_alloc(11BA)
- top stack frame, we get to a value tagged INSPTR, seg fault
- ra slot is 32, but the insptr is found at 21
- many functions just inlined into rt_str_alloc
- instr.block is null...
  - must have been an old call site, now inlined

[DONE] FIXME: es5_comparisons, 4 >= 34 ==> false (expected true)
inlining $rt_refIsLayout(2B6A) into $rt_valIsString(2B7A)
inlining $rt_obj_get_header(12A2) into $rt_valIsString(2B7A)
- problem: replacing call uses by ret phi, but uses can be phi in call continuation!
- can't directly put the ret phi in the call continuation, needs its own block

[DONE] TODO: if no inlining happened, don't re-allocate stack slots

[DONE] FIXME: missing phi argument for:
$87 = phi [, call_reg(EBA3):0 => $295, call_cont(EB9F):0 => undefined]
in block:
if_join(E83B):

[DONE] FIXME: nsieve-bits segfaults
- Try logging executed instructions again
- Inlining itself fails for $rt_valIsString(2B7A) into $rt_setProp(2D02)

[DONE] FIXME: copying eliminates phi args

[DONE] FIXME: phi node is missing arg from one branch post inlining
- missing phi arg from call_reg

[DONE] TODO: rework inlinePass
- KISS, top of stack replacement only for when at call entry

[DONE] TODO: add interpreter cycle count, add to stats?
- move stats out of jit namespace?
- --stats option

[DONE] TODO: refactor inlining function

[DONE] TODO: implement heap_alloc in JIT?
- interp.allocPtr + size > interp.heapLimit
- if past heap limit, bailout
- increment interp.allocPtr
- align interp.allocPtr
  - align: +7 & -8
  - + (ptrSize - 1) & -ptrSize
  - drops the low 3 bits
- if the size is a multiple of ptr size, no need to align :)
- fasta unjitted instrs, 541366 vs 853500
  - but not much faster!

[DONE] TODO: better JIT ret handling for too few or too many args in call & ret
- Special handling branches should go out of line, return to main line
- ret bailouts
    3d-raytrace     3.3K    2.4K
    string-fasta    4.8K    0
    earley-boyer    271K    266K

[DONE] TODO: think about different inlining strategies
- Can create new IRFunction & replace in closures, but...
  - Still need to mutate an IRFunction during inlining
- Current scheme might still be best
- Can simplify for now by avoiding top of stack replacement, gets most gains

[DONE] FIXME: bug in earley-boyer
core.exception.AssertError@ir/ast.d(162): cannot add instr:
jump
current block already has final branch:
call_cont(1BC38):
  ret t_1BC37
in function "anon(1AECE)"
./higgs(void ir.ast.stmtToIR(ir.ast.IRGenCtx, parser.ast.ASTStmt)+0x1181) [0x575dfd]
./higgs(void ir.ast.switchToIR(ir.ast.IRGenCtx, parser.ast.SwitchStmt)+0x3a2) [0x5768be]

[DONE] TODO: jit.stats, total size of machine code generated

[DONE] FIXME: bug with 3d-raytrace introduced by stack slot opt
- only happens in context of make test
- crashes while during GC, while visiting stack roots
    forwarding object 3 (false)
- Probably, stack slot gets corrupted somewhere in the JIT
- A single phi node is producing this value ***
  - Uses values from a call and from another phi ($30)
  - $30 was already forwarded
$119 word: 3
$119 type: INT32
$30 word: 47386518933928
$30 type: REFPTR
Type comes from $30...
Value comes from $119
On path from $119 (call cont), phi is assigned to r11
REFPTR type is written to the stack
On path from $30, phi is also assigned to r11
When doing GC deep down the stack, need to have spilled r11
May not ever spill this phi node if it isn't live after the call ***
This is a peculiar situation... Type is on the stack but value is in a reg

[DONE] TODO: all instrs whose value is not used can share one stack slot

[DONE] TODO: get_arg for V8/raytrace
- 782K unjitted, 3.3s
- 620K unjitted, 3.2s
- still many many ret bailouts

[DONE] TODO: blog
- JIT complete, now with SSA
- Difficulties encountered, phi nodes, reg alloc bugs, call/ret bugs
- For now reg alloc simple
- Better code quality, speedups (table?)
- Higgs would ideally need fuzz testing

[DONE] TODO: StoreOp
- 3d-raytrace at 2.4s
- V8 raytrace now fast enough

[DONE] TODO: add call bailout and ret bailout JIT stat, try on string-fasta
- 3d-cube and 3d-raytrace have a few thousand ret bailouts
  - wasting time in the interpreter
- string-fasta has about 4K ret bailouts only
  - might still amount to a lot of time in the interpreter

[DONE] FIXME: some kind of phi node bug in $rt_getPropIdx
- once mod_i32 introduced, value gets de-incremented?
- spilling a register, but the value is mapped to the stack
  - mapping of reg to values got broken
- bug when phi node reg is in use by said phi node

[DONE] TODO: mod_i32 op
- 3d-raytrace unjitted ops down to 7.1M, string-fasta down to 17.9M

[DONE] TODO: gen_call, accept type imm

[DONE] TODO: how many unjitted instrs in string-fasta?
- about 28M
- does a lot of ret bailout, probably most of the problem

[DONE] FIXME: string-fasta segfaults at the end?
- No call or ret bailout
- global v is not the corrupted value...
- something gets written at the wrong position?
- what if our type tag gets written in the wrong place?
- bug in set_global implementation

[DONE] TODO: check ref ptr values stored in interp StoreOp

[DONE] TODO: void checkVal(Assembler as, X86Opnd wordOpnd, X86Opnd typeOpnd, string errorStr)
- use CMP to check value, jump to final label if OK, otherwise print errorStr
- use this in set_global to try and find when problems happen

[DONE] TODO: implement get_word, get_type
- 3d-raytrace now 8.0M unjitted

[DONE] TODO: implement set_value
- originally 9.25M unjitted instrs, 3.6s
- now 8.2M unjitted instrs

[DONE] TODO: logging of default JIT ops using ctx.as.printStr, test on 3d-raytrace, string-fasta
- lots of store(s)
- $2 = get_type missing
- $0 = set_value $20, $21
- $2 = get_word $29
- lots of mod_i32

[DONE] TODO: stat counter for number unjitted instructions executed
- 9.5M for raytrace, probably dominates execution time!

[DONE] TODO: dynamic type tests, incr counter only if jit_stats enabled

[DONE] TODO: exec time stat? record start time in static ctor
- Could we log stats in static dtor???

[DONE] TODO: can we compute comp time using microsecs to make more accurate?
- 3d-raytrace, 327ms out of 3675ms

[DONE] TODO: jit.stats, stats.compTimeMS
- What is the comp time for 3d-raytrace? 304ms out of 3800ms

[DONE] TODO: optimize non-constant comparison followed by if_true
- cmp can check that if instruction follows and is the only use
- if can check that cmp instruction precedes
- could possibly directly check the last ASM instruction?
- time benchmarks before if opt, best of 5
3d-cube             1.75    1.65
3d-raytrace         3.84    3.5
bitops-nsieve-bits  1.14    1.12
access-fannkuch     2.32    2.28

[DONE] TODO: improve cmp + if_true
- can generate bool and then cmp independently
- must modify ifTrueNext
- generate bool if we have more than one use or no if_true follows
- generate the if_true if one immediately follows

[DONE] FIXME: segfault after if opt.
- Problem is not with single use
- using for only IsTypeOp seems to work
- two versions of a null comparison, one fails?
- Problem is, for comparison, we can only do do cmp in the comparison operator...
  - Might need an implementation of if_true to which we can supply our own comparison operators...
  - if_true just calls implementation if bool arg doesn't immediately precede
- need void genCondBranch(trueOp, falseOp)

[DONE] FIXME: assembler fixed point goes into infinite loop...
- Computed jump offset can be wrong
- If jump instr becomes shorter, label offset is no longer accurate in current pass
- May recompute offset and get wrong answer because label position is no longer valid

[DONE] TODO: boolArgPrev
- Can avoid comparing against true val if cmp already done!
- most often true, but not always, sometimes because of phi

[DONE] TODO: implement ifUseNext(IRInstr) for IsTypeOp and CmpOp
- log occurrence: 80 to 90% true

[DONE] TODO: implement more opts in JIT, target defaults of slower benchmarks
- i32_to_f64? already commented out
- 3d-raytrace time?

------------------------------------------------------------------------------

[DONE] FIXME: error in v8/richards
- also issue with call bailout

[DONE] FIXME: segfault in v8/deltablue
- when fixed, enable in unit tests
- does this fix other segfaults?
- crashes somewhere in the plan execution
- modifying Plan.prototype.execute causes it to work properly
- get the IR string for this function?
  - just one phi node for the loop increment
  - mostly function calls
entering fn: Plan_prototype_execute(F529) (for_test(F642))
Segmentation fault
The call to c.execute crashes
Call bailout happens in this function just before the crash!
- Forgot to put loadVal=false in all getWordOpnd calls

[DONE] TODO: JIT currently checks if call instr has out slot, do we still have
situations where we don't allocate an out slot to call? test it

[DONE] TODO: cleanup call cont generation code
- add ctx.genCallCont function
- remove getEntryPoint from there

[DONE] FIXME: bug with sunspider/3d-cube, mov xmm0, 0;
- How do we load an immediate into XMM?

[DONE] TODO: re-benchmark and re-enable more sunspider/v8 tests

[DONE] TODO: getTypeOpnd in gen_ret should have acceptImm = true

[DONE] TODO: valToString should validate ref pointers
- core.memory.query, returns null if invalid pointer

[DONE] FIXME: bug in stackvm with ret enabled
- doesn't happen with interp ret only
  - much less JIT execution
- Does it crash when run on its own? Yes
- Does it crash if we disable GC? Yes, after a few runs (enough for JIT?)
- Try disabling specific ops, like load?
./higgs --nostdlib programs/regress/jit_ctor.js
- segfaults with object ctor call, adding property, returning new object
- many conditions need to occur
- Disabling load fixes the segfault...
  - Enabling just load_u32 makes it happen
    - 5 instances
  - pointers and offsets passed seem valid
  - doesn't seem like the load itself is causing the segfault
- Load code seems correct, try disabling other ops
- Bug in ret bailout code, state doesn't match entry state
  - need to set loadVal=false in getWordOpnd

[DONE] FIXME: jit ret causes infinite loop in stdlib, setPropObj
- Not caused by phi nodes
- Return value somehow not set?
  - interp and jit ret should be doing the same wrt return value
- Seems we get a loop with always the same next pointer returned
  - but the return code seems correct
- The situation we have occurs with a loop... The loop definitely has phi nodes
- Seems we really have an object with itself as next value
- Disabling ret makes it work
  - disabling jit ret doesn't fix it
  - disabling jit call cont generation doesn't fix it
- must be a phi node issue with the interpreter
- wspReg, tspReg not set in interpreter before interp.branch

[DONE] FIXME: jit entry point should be executing the phi moves...
- interp entry point doesn't execute moves, because the interpreter
  already executed them in the branch() function
- Could put a special pointer on the call instruction
- genBranchEdge to generate the phi nodes?
  - need to use stack entry state
- store association between label and call instr
- at the end of compFun, write the pointer
    ctx.genBranchEdge(
        ctx.ol,
        new Label("cont_branch"),
        instr.getTarget(0), 
        new CodeGenState(fun)
    );
- fixup gen_ret to use jitCont
- also make the branch edge exported
- add jitCont pointer on IRInstr

[DONE] FIXME: printStr is broken

[DONE] TODO: reimplement ret instruction in JIT
- need to fix jump(reg) to work branch desc
- move code into ret, it's the only usage

[DONE] FIXME: es5 comparisons, 2 !== 2 ==> false (expected undefined)
- undefined, wrong value extracted from array?
- try prop read loop in REPL?
- try disabling comparisons?
- make small regression test again
- test passes when JIT comparison ops disabled
  - fails if eq_i8 enabled

[DONE] FIXME: segfault once JIT call is enabled
make; ./higgs --nostdlib --jit_dumpinfo programs/sunspider/bitops-bitwise-and.js 
- segfaults if using interp call
- no segfault if interp call and no call continuation
- no segfault with JIT call and no call continuation
- still segfaults with stdlib enabled
  - after $rt_obj_get_cap compiled?
  - disabling JIT load ops seems to fix this
  - wrong reg used in load

[DONE] TODO: debug mode tests in load ops

[DONE] TODO: reimplement call instruction in JIT
- might cause load ops to be triggered, bugs to pop up, we shall see!

[DONE] FIXME: get_global, set_global, cannot allocate IR value for constant

[DONE] TODO: fixup load ops in JIT
- Also improve codegen wrt imm

[DONE] TODO: set_global, get_global

[DONE] TODO: asm peepholes, eliminate jump after jump

[DONE] TODO: re-enable JIT-specific unit tests

[DONE] TODO: reimplement basic arith

[DONE] TODO: reimplement eq instructions

[DONE] FIXME: CmpOp causes malfunction?
- Causes some values to be loaded from the stack...
- Neither $rt_se nor $rt_toBool have phi nodes, so this is probably not the issue
- Seems we get issues when using EDI as our output reg?
- Not obvious at all what's wrong
- Issue is with CmpOp not writing the upper 32 bits of memory words
- Fixed if_true implementation in interpreter

[DONE] TODO: copy es5_cmp, simplify until bug disappears, regress_cmp
- use --nostdlib to minimize interference
  - no JIT usage
- only one instance of eq_i32, in $rt_se

[DONE] TODO: check that phi nodes aren't getting the same register in succState

[DONE] TODO: reimplement if_true instruction

[DONE] FIXME: interp.d(538): ref ptr out of heap
- es5_cmp benchmark, many ifs
- no gc
- phi moves are involved
- Check if if_true code is correct...
  - all cases are exerted
- Log if cycles occur
  - no cycles
  - several mem-mem moves, type info
  - few moves, moves seem normal
- if args are all regs
  - two of the args are phis
  - are we loading them properly?
  - mapping all phis to stack doesn't fix the problem
./higgs --e "test()" --jit_dumpasm programs/es5_cmp/es5_cmp.js 
entering fn: $rt_valIsString(2B7A) (entry(32C2))
- disabling IsType ops seems to fix the problem
- test in more detail what in IsTypeOp causes an issue
- Bug in loading from mem to reg, not loading all the bits
- Also bug in getTypeOpnd

[DONE] TODO: reimplement jump instruction

[DONE] FIXME: mov r12l, [qword r14];
- 8-bit dst? wtf?
- getWordOpnd mem opnd wrong

[DONE] FIXME: getTransLabel, can't just insert instructions immediately!
- Might be called at various points inside an instruction
  - branch instructions only, at end of blocks
- Need to wait until end of current instruction
- can queue until end of current block
- What if we supplied a label to getTransLabel?
  - Call genBranchEdge at the end

[DONE] TODO: fix execMoves wrt tmp reg size
- add sanity checks, ie: no move into imm

[DONE] TODO: X86Reg.ofSize

[DONE] TODO: block transitions, state transition handling
- getTarget, need to generate code
- Need mechanism to handle block transitions w.r.t. phi nodes
  - "Execute" the phi assignment at the beginning of that block
  - Update state to reflect which phi nodes are in slots or regs
  - Insert moves as appropriate
  - May have cycles between phi node moves

[DONE] TODO: fix getWordOpnd
- used once in SpillRegs
- used by block trandition!
- need to be able to prevent load
- comment out current implementation and try reimplementing?
- getCurOpnd sub-function?

[DONE] TODO: fix getOutOpnd

[DONE] TODO: reimplement is_i32 instruction, IsTypeOp

[DONE] TODO: fix getOutOpnd

[DONE] FIXME: getEntryPoint, interp already executed phi nodes
- Doesn't make sense to generate new phi node mapping
  - phi nodes should remain on the stack as they were
- Could add a "noLoadPhi" arg. Simple enough

[DONE] TODO: fix getTypeOpnd

[DONE] FIXME: don't want to need interp pointer to evaluate constants
- could make static interp method, callable with interp or null

[DONE] TODO: re-enable jit call in interpreter
- get jit working with defaultFn only
- no branch handling for now, bailout to interpreter pre-branch

[DONE] TODO: fix defaultFn

[DONE] TODO: implement IRInstr.hasArg(IRValue)

[DONE] TODO: fix spillRegs calls

[DONE] TODO: fix spillRegs implementation
- if something is dead, delete it from the map, no more RA_DEAD

[DONE] TODO: replace liveSets by liveQueryFn

[DONE] FIXME: Object.keys({length : 1}).length == 0
keys there should give ["length"] but instead you get []
- Test in REPL
- Add object unit test

[DONE] TODO: make register mapping use values instead of local indices

[DONE] TODO: move list execution function
- uses one temp reg
- algorithm:
  - Identity moves are removed
  - If no moves don't overwrite an src, take pair (A->B) and remove from list,
    move A into tmp, add (tmp->B) to list
  - Pretty simple iterative algorithm!

[DONE] TODO: dumb register allocator
- need to test our ideas first, quality reg alloc is not on the critical path

[PASS] TODO: smarter slot/register mapping pass, jit/regalloc.d
- Only map registers for now, later map both slots and regs
- Ideally, slot/reg allocation assigns vals and phi nodes to same slot/reg
  - Provided they don't interfere
- Ideally, values that share a phi target end up in same register
- Should do phis first, values after?
- Should produce mapping of values to slots, allows remapping stack frames
  - Don't compute liveness just for interp, that's expensive
- Map instr to first slot that's not already mapped to an interfering value
  - Grow num slots as needed

[DONE] TODO: how often are phis live/interfering with their non-const arguments?
- compute stats in astToIR to get this info
- Liveness... Do we need more info?
  - Can manually test if used by a phi node if necessary
  - When checking if phi interferes with arg... Doesn't matter if val is live
    while phis are being assigned into if the val isn't live after
- Phis and args do sometimes interfere but most of the time not ***

[DONE] FIXME: live vars queries with instr from block that isn't in the function anymore?
- instr.block.fun is null (so block was removed from function?)
- we got this instr from a phi argument
- normally, incoming branch should have been removed
- PROBLEM: if instr had been removed, its block would be null...
- delBlock in peephole.d causes this to happen
  - only deleting dead blocks... removing incoming to other blocks
  - our instructions should have null block
- the instruction is still the valid last instr in the block!
- block was deleted, should have no instrs...

[DONE] TODO: jump to if_true of phi opt pattern
- Occurs in $rt_add
- pred can potentially be made to do if instead of jump
- succ must have just this one phi, which feeds into the if
- down from 6 to 2 phis in $rt_add!

[DONE] TODO: fixup liveness analysis to work with SSA
- better liveness data structure?
- could have dead/kill points for values?
  - if no uses, immediately dead
  - can die on branches

[DONE] TODO: read SSA liveness PDF
- Should really use bit sets for liveness if possible
- Could we produce live sets as query-able closures? ***
  - Internally store bit set(s), instr to id mapping
  - Probably not that inefficient
  - If each instr has a bit set, could allocate quadratic storage contiguously
    - Instrs/phis with no uses get no entry
    - Can log biggest table size for ease
- Paper says "variable by variable approach" performs best, read section 5

[DONE] TODO: fix loop bug w.r.t. loop vars and continue

[DONE] TODO: remove dead instrs peephole
- hasNoUses, !opcode.isImpure, !opcode.isBranch
- Actually very few dead instrs, probably a good thing

[DONE] TODO: $nullptr
- add unit test for typeof $nullptr, typeof $argc

[DONE] TODO: in ir/ast.d, flip ctx arg to be first in *toIR functions

[DONE] FIXME: null owner block for phi use
- phi node is not attached to a block
- have phi node use that was deleted, but not properly unregistered
- PROBABLE: we make a block dead, and it has arguments to some phi
  - branch is removed, but phi args never removed
  - remIncoming should unregister all associated phi args

[DONE] TODO: jump to jump peephole opt
- block with only branch instr, no phi nodes

[DONE] FIXME: jump to jump peephole doesn't seem to work when done with call
and phi args are allowed...
- ret instr in interpreter seems capable of handling phi args...
- Need to set ret val before executing phis!

[DONE] TODO: int32 add const prop peephole opt

[DONE] TODO: fixup FFI
- extract args into buffer

[DONE] TODO: basic IR peephole pass
- look at irString for primitives, add, getProp, etc before and after
- opts:
  - phi node opts
  - dead blocks
- See if interp performance changes much
bitwise-and     7.24    6.8-7.1
nsieve-bits     77.6    69

[DONE] FIXME: GC bug after phi replacement, gc/closures
- ops.d(613): pointer is not pointer type in load op
- new_clos triggers the collection
  - clos allocation itself triggers collection
- crashes in $rt_cell_get_word, inside of closure code
- cell pointer set to wrong value? or maybe in wrong closure?
  - very unlikely
  - we are calling the right closure object
- cell pointer we got from closure (clos ptr arg to call) is wrong?
- final get seems to be what fails...
  - adding prints in test function or getCellVal seems to make this issue go away
- As soon as the GC executes, tsp[3] becomes corrupted. How is this possible?
- GC corrupts type stack when zeroing it out using wrong pointer type!

[DONE] FIXME: phi moves don't swap properly... would have to all be simultaneous
- could load all arg values into a temp vector, then copy temp vector?
- preallocate temp vector for phi, calls in interp, not that inefficient!
- eliminate alloca

[DONE] FIXME: phi uses deleted phi
- removing "first use", but firstUse is null... val already deleted?
  - could we be marked as a use of ourself? should not be an issue?
- Can't just destroy phi nodes or instrs when removing block
  - May have other (dead, uncollected) uses still referencing them

[DONE] FIXME: removing phi nodes always results in a seg fault? why?
- printing some instr fails while printing args...

[DONE] TODO: get jit.d compiling with JIT disabled

How should the SSA JIT work?
- Moves may need to be generated for some phi nodes, when jumping to a block
  - getTarget may need to take pred into account, generate stub of moves
- Current state: whether each value is in its register or slot
- Will need a way to request an argument as a register
  - If it's a constant, we need to supply a temp
- If I have some phi incoming in a slot, and I branch to a block, I'll be
  redefining this phi node, hence the state I branch to should have that phi
  also in a slot, if they're the same ***
- Maybe the JIT shouldn't make phi nodes have fixed slots?
  - This only matters if phi incomings and phi nodes often interfere ***
    - Must compute this stat to inform our decision

------------------------------------------------------------------------------

July 15th goal: complete AST->IR and interpreter refactoring

[DONE] TODO: rebase main branch onto SSA

[DONE] TODO: fixup GC
- Try enabling GC tests in steps

[DONE] TODO: grep for FIXME

[DONE] TODO: exceptions, try-catch-finally
- Finally execution
- Try/catch/finally, context merging
- Throw, throw ctx lst? See Tachyon
- genExcPath needs to be altered

[DONE] FIXME: trying to add instr after call to rt_add
- Seems to be caused by englobing try block... genExcPath?

[DONE] TODO: for-in loop
- crash, first call to enumerator fails

[DONE] TODO: arguments object

[DONE] TODO: call_apply

[DONE] FIXME: "programs/basic_assign/basic_assign.js" produces 20

[DONE] TODO: new operator

[DONE] TODO: switch statement
- Needed to load stdlib
- Look at Tachyon code

[DONE] TODO: array literal support

[DONE] TODO: object literal support
- Should enable many more tests

[DONE] TODO: delete operator
- Signal 11 on delete of global

[DONE] FIXME: $rt_toString(5), ir.d(932): phi node is not attached to a block
- Replacing value by unattached phi node????
- Problem: replacing uses of phi but, phi may be in context already
- Shouldn't be doing this during code gen... Need separate opt phase

[DONE] TODO: typeof operator
- Has its own unittest section

[DONE] TODO: for loop

[DONE] TODO: do-while loop

[DONE] TODO: compare Tachyon and Higgs WhileStmt versions
- Possible improvements for clarity/simplicity? Refactor now
- createLoopEntry? look at Tachyon usages, do we always register labels?

[DONE] TODO: get simple while loop with phi nodes working
- can now test this with --nostdlib --e "..."

[DONE] FIXME: break/cont target should have both ctxList and IRBlock
- enable some loop tests

[DONE] TODO: operator ++

[DONE] FIXME: signal 11 at ret in basic tests
  call_cont(26473):
    $0 = or_i32 $5, $8
    ret $0
- phi node assigns into RA!

[DONE] TODO: --nostdlib option?

[DONE] TODO: log branch target idx in phi toString

[DONE] TODO: if you do remPhi, should remove args for that phi node
- BranchDesc.remPhiArg(PhiNode phi)

[PASS] FIXME: phi nodes with 0 or 1 input
- seems valid for now...

[DONE] TODO: test if 1 + 1 (runtime, arith ovf) is working
- Missing if statement support

[DONE] FIXME: visible argument slots wrongly assigned?

[DONE] FIXME: phi node toString doesn't show any incoming values
- desc.args.length: 0

[DONE] FIXME: newlines in IR listing

[DONE] TODO: ternary expression

[DONE] FIXME: r/ast.d(1854): variable declaration not in local map: "x"
- x is a parameter to $rt_add
- local map length: 0

[DONE] TODO: && operator

[DONE] TODO: if statement

[DONE] TODO: jump with branch descriptor, handle phi nodes
- interp.getValue(IRValue val)
- interp.branch(BranchDesc branch)

[DONE] TODO: set_str

[DONE] TODO: set_undef... Do we want to implement a $undef and $missing?
- Like $argc

[DONE] TODO: new_clos, needed by runtime lib

[DONE] TODO: get set_global, get_global working
- Needed for even basic runtime
- x = 1; return x;

[DONE] TODO: get basic "1", "ir_add_i32" working in interpreter

[DONE] TODO: getArgVal

[DONE] TODO: add loadRuntime option to interpreter

[DONE] TODO: make callFun interp method

[DONE] FIXME: temps are not per-block

[DONE] TODO: implement simple stack slot assignment pass
- should be called at end of astToIR
- ir/slotalloc.d, allocSlots(IRFunction)
- instrs with single uses *in the same block* interfere with other from block
  - these are "bounded" temps (same block bound)
  - each get a slot from tempSlots
- instrs in the other category interfere with everything
  - each get their own slot from varSlots
- for now phi nodes get own slots too, from varSlots

[DONE] TODO: rename "dsts" to uses, less confusion

[DONE] FIXME: do you consider branch desc args as uses? ***

[DONE] TODO: comment out currently broken tests, get make test working

[DONE] TODO: get IR gen for function calls working

[DONE] TODO: get IR gen for function decls working

[DONE] FIXME: get x = 1 working

[DONE] FIXME: get while (1) to work
- genRtCall is incomplete

[DONE] TODO: get while(true) to work

[DONE] FIXME: merge ctx should check if branch exists
- If branch present, find matching target

[DONE] TODO: context.merge(subCtx)... proper local map handling?

[DONE] TODO: IRGenCtx.dup? Bring back subCtx! less copying overhead

[DONE] TODO: IRGenCtx.ifTrue

[DONE] TODO: adapt context for loops, break ctx list, cont ctx list
- No longer want exit and continue blocks, but lists instead

[DONE] TODO: convert genBoolEval
- KISS for now, improve with SSA way later?

[DONE] TODO: mergeContexts
- In Tachyon, with the output of mergeContexts
  - Set it as the "output" (continue generating code there), like .merge
  - Continue generating code from a new context with that block
- Creating a new context seems like the safer, cleaner option (and probably just as fast)
  - Much cleaner abstraction

[DONE] TODO: mergeLoopEntry?

[DONE] TODO: method to set/add branch desc argument?

[DONE] TODO: createLoopEntry
- creates phi nodes for each variable going through the loop
- start by making basic while loop work!

[DONE] TODO: test simple functions/expressions
- print text output
- modify main to do this? return early

[DONE] TODO: fixup IRFunction.toString

[DONE] TODO: begin porting stmtToIR, exprToIR
- constant exprs
- arith add
- statement expr, return expr

[DONE] TODO: modify/port (most of) astToIR function to get familiar

[DONE] TODO: port genRtCall
- needed for astToIR function

[DONE] TODO: mutable int32 IR value? IntVal?

[DONE] TODO: modify IRGenCtx
- outValue
- localMap

Context merge idea: we must make the contexts jump/branch to the right block
(we do this already). Must also create phi nodes and add incoming values as
appropriate.

It seems like we probably could have a simpler mergeContext that works on
an individual context basis... 
- mergeLoopEntry uses a map of entryLocals and an entryBlock
- createLoopEntry creates a phi node for each variable going through the loop
  - no choice without prior knowledge

Tachyon IRConvContext has:
labels,
localMap,   // Mutable map of local variable states
sharedMap,  // Map of shared variable locations
breakMap, 
contMap,
throwList,  // Throw context list
funcObj,
thisVal,    // This argument value
outValue    // Output value of the evaluated AST node

IRConvContext.prototype.setOutput = function (exitBlock, outValue)
- Note: exitBlock is no longer necessary

// Create a context for the loop entry (the loop body)
var entryLocals = new HashMap();
var brkCtxList = [];
var cntCtxList = [];
var bodyContext = createLoopEntry(
    astStmt,
    astStmt.statement,
    context,
    entryLocals,
    brkCtxList,
    cntCtxList,
    'loop_body'
);

// Merge the break contexts
var loopExit = mergeContexts(
    brkCtxList,
    context.localMap,
    context.cfg,
    'loop_exit'
);

// Merge the continue contexts with the loop entry
mergeLoopEntry(
    cntCtxList,
    entryLocals,
    context.localMap,
    testContext.entryBlock
);

// Merge the local maps using phi nodes
var joinBlock = mergeContexts(
    [trueContext, falseContext],
    context.localMap,
    context.cfg,
    'iir_join'
);

[DONE] TODO: string constant IRValue

[DONE] TODO: get code into compiling state
- Comment out code until things compile?
  - Comment out most of ir/ast.d
- getArgSlot?
  - for interp, assert use has an out slot

[DONE] TODO: remove useless instructions
- set ..., move

[DONE] TODO: remove original IR classes, replace by new ones

[DONE] TODO: implement SSA IR
- Constant pool for int32s, float64s, true/false/null/undef/missing
- Remove instrs that are now constants

[DONE] TODO: fix dependency cycle ir.ir -> interp.ops -> ir.ast -> ir.iir -> ir.ir

[DONE] TODO: disable various IR analyses

[DONE] TODO: disable JIT for now, comment out aside in makefile

------------------------------------------------------------------------------

[DONE] TODO: think about register kill in ASM, would be very useful
- Combined kill with bit mask of GP registers to kill
- KillRegs annotation
- Only insert if !jit_noasmopts
- slows the code gen a bit...
  - another argument for SSA
- this idea actually sucks

[DONE] TODO: basic peephole opts

[DONE] TODO: jit_noasmopts flag

[DONE] TODO: try to use one less scratch reg, commit before
- Benchmark first, note times ***
  3d-cube               2.45    2.50
  3d-raytrace           4.34    4.43
  bitops-nsieve-bits    1.32    1.33
- Grep for scrRegs64[3]
- Result: no noticeable difference!

[DONE] TODO: lsft_i32, rsft_i32

[DONE] TODO: test simple artificial benchmark for study
- for_loop.js, just a for loop that increments a counter
- issue: quite likely, w.r.t. const prop, global values aren't optimized
  - global version is a little slower
- stare at ASM, make it better
- Observations
  - lt, add successfully inlined in main loop
  - tons of stubs are produced, should probably optimize stub compilation
  - with lots of iterations, it's almost twice as fast with inlining
- when we do get_global, we copy the type to the stack, but we keep the
  value in a register. We then write 0 to the stack to prevent a type out
  of sync problem...
- jumps to next label are quite common
- int offset in load instr could be optimized

[DONE] FIXME: useless move in simple for loop, closure version
- Flaw in init analysis w.r.t. dead code and argument initialization

[DONE] FIXME: bug in 3d-raytrace, has to do with set_true, set_false
- Fn args could be constant, but call/ret wouldn't know?
  - Test if this is the case

[DONE] TODO: getWordOpnd: provide a tmpReg parameter

[DONE] TODO: rename getArgOpnd to getWordOpnd

[DONE] TODO: getTypeOpnd, do we ever get a type that's not an instr argument? grep it

[DONE] TODO: eliminate getReg

[DONE] TODO: restructure/simplify call, spill everything *after* arg copying

[DONE] TODO: SET_TRUE should store its constant

[DONE] TODO: optimize IsTypeOp

[DONE] TODO: add flags for known boolean values, defer value write?
- Allows optimizing both IsTypeOp and if_true
- If opnd is requested, move value to opnd
- If spilling, write value
- Probably need a special TF_CONST

[DONE] TODO: basic OSR if function is on top of the stack
- Easy at this point? Just move the values to the new slots
- Fn on stack must be interp function if we're in compFun
- Large majority of stuff isn't deep on the stack when compiled
  bitops-nsieve-bits shows $rt_arr_ofs_len as "deep"... How???
  - Could an old RA be left over on the stack, not used?
  - Try implementing proper stack traversal
- Disable temporary compFun in callFun

[DONE] TODO: remove localMap thang from inlineCall, not needed

[DONE] TODO: re-implement FP ops in JIT

[DONE] FIXME: v8bench/splay borks the JIT
- operand is null, nonsense!

[DONE] TODO: GC unit test
- Alloc small object, add more properties, trigger GC,
  try accessing latter properties

[DONE] FIXME: GC bug with next chain
- Segfault in gc/graph after collection is done
- GC is artificially triggered by shrinkHeap, not during allocation
- Crashes somewhere while setting up initial graph
- Seem to be crashing on array push
- Crashing when trying to get a closure cell property (array_toObject)
  - $rt_getCellVal
- Quite possibly our closure got a next pointer before the cells were set!

[DONE] TODO: interpreter stack traversal function with delegates?
- use for GC, funOnStack
- delegate with: IRFunction fun, wsp, tsp, size_t depth

[DONE] TODO: blog, Implementing Inlining
- Inlining in Higgs
  - OSR aspect
  - nontrivial, stressing the JIT, bug fixing
  - frame compaction, optimization
  - most tests show slight perf loss, some slightly faster
- Plans: more libs, graphics/audio wrappers, testing system
  - Competing with Python?
- DConf 2013 talk in a week or so
  - Will be announced and linked on this blog and on my twitter feed

[DONE] TODO: investigate why most functions get no inlining, including $rt_add, $rt_lt
- Lack of inlining partially explains lack of speed
- bitwise-and is a loop, won't inline anything without basic OSR
- rt_add, rt_lt themselves don't really need inlining for the common case
- must have basic OSR to see change in functions with loops
- 3d-cube is actually faster

[DONE] TODO: re-implement add_i32_ovf in JIT

[DONE] TODO: re-implement set_f64

[DONE] TODO: for inlining, be a little smarter
- Check if arg count never read, if so don't write it
- Check if arg slots never written, if so use arg vals directly

[DONE] TODO: jit_noinline flag
- remove plain jit_noopts, not specific enough
- 3d-raytrace still 0.6s faster without inlining, 3.5 vs 4.3

[DONE] TODO: IR flag for non-pure values, things we can't safely remove
- STORE_..., SET_LINK, SET_GLOBAL, EVAL_STR, PRINT_STR, CLOSE_LIB, GC_COLLECT
- OpInfo.IMPURE

[DONE] TODO: optimize instructions needed for inlining
- set_rawptr, eq_rawptr, set_i32, load_rawptr
- produces some speedup, but still not as fast as uninlined
- moves may be quite inefficient

[DONE] TODO: test performance on raytrace, bitwise-and? try increasing fn size limit
- Raytrace is twice as slow, 4.4s vs 10s

[DONE] TODO: test inlining with functions not currently on stack (pre-OSR)
- funOnStack
- ISSUE: all functions are on the stack when compiled!
- For now, temporarily call compFun in function call bit?

[DONE] FIXME: rt_sub used for negative numbers in JS layout computation!
- Look at irString, $rt_clos_ofs_cell
- Fix in parser

[DONE] FIXME: inlined rt_sub is compiled all wrong???
- Move instruction doesn't copy type tag properly?
- Disabling gen_move fixes problem
- Immediately after move, is_int32 fails
- IsTypeOp doesn't account for known type tags

[DONE] FIXME: segmentation fault on Higgs init
- JIT is probably calling valIsString with the wrong stack frame size
- Optimized call based on pre-inlining size

[DONE] TODO: JIT string printing mechanism

[DONE] TODO: test inlining with the JIT off first?
- Tests pass without JIT and without inlining
  inlining $rt_setCellVal(22E120) into clos(2380CD)
- invalid move dst in clos() function
    $4 = set_undef
    move $4
    jump => call_cont(23812C)
- Call with no return value unhandled

[DONE] FIXME: segfault when executing fun w/ inlining
inlining $rt_obj_ofs_type(11AC) into $rt_obj_set_type(11D6)
- Arguments not copied right, inverted order

[DONE] FIXME: segfault during JIT compilation

[DONE] FIXME: pointer is not pointer type in load op, failing to load from clos ptr

[DONE] TODO: implement size limit in inlining test

[DONE] TODO: funOnStack
- Just scan the stack for RAs, very simple

[DONE] TODO: go over inlining implementation, inspect code

[DONE] TODO: implement inlining
- Maintain original call cont blocks
- Keep track of who's inlined at each call site, for exception stack unwinding
  - Map of call instrs to lists of functions
- Produce mapping of pre-inlining stack slots to inlined slots, for OSR
  - Map of stack indices to stack indices

[DONE] TODO: change function layout so function pointer has fixed offset
- Get offset of word slot 0?
- on alloc class, add numRsvProps parameter

[DONE] TODO: fix closure ctor_class issue

[DONE] TODO: IR, i64 tag, support

[DONE] TODO: IR instr renaming for convenience
- is_i32, is_f64, ...
- set_i32, set_f64, set_str, ...

[DONE] FIXME: crypto-aes, run-time error: undefined base in property read
- array w in KeyExpansion should have been initialized with array, is not
- Likely, failing because loop index is not integer

[DONE] FIXME: crypto-aes, invalid operand 2 type in op "auto r = x * y;" (int32)
- Investigate, create failing unit test
- Problem with new Array, size resulting from division is a float

[DONE] TODO: blog
- DConf, impressions
- method JIT, versioning
- talk slides
- forum.dlang.org/group/digitalmars.D

[DONE] TODO: fix loop label segfault

Publishing: figure out their litmus test. For some, numbers, for some it's
proofs, make sure you have that
- You're selling something, try to have a grand narrative
- Why it's hard, why it's interesting, why is it novel
- Papers you *should cite*, how does it compare
- Try to cite the reviewer...?
- Cohesion, line of thought, don't want sections to look like afterthought

Michael: try to do these optimizations by hand on some benchmarks, where will it pay off?
- I wasted a lot of time trying to do clever things I thought would matter

Michael: constant folding, copy propagation, try to predict benefit? *****

Michael: either work backwards or you backtrack
- Or do it greedily backwards?

Shu: flow problem. Want to optimize CFG to reduce joining work.
- Attach weight to individual nodes based on amount of work
- How much work did we save?
- Model performance characteristics

Problem: add operator, overflow case... Don't want this automatically compiled
- Whole other loop path for doubles?

Michael: don't want duplication to propagate all the way through
- Merge as early as possible
- Metric of benefit vs cost of duplicating a block
- If merging from two different types, we get boxing overhead

Max: Incremental duplication may be necessary... Prevents impossible/useless
duplications to some extent. Otherwise duplication can propagate to successors.
- Similar problem to trace trees

Michael: if you duplicate a block, what is the probability you'll have to
duplicate its successors

Michael: tail duplication has been around for a long time, lots of literature

Michael: would be interesting to try and predict if tail duplication will help
at a specific point

Michael: come up with a metric
- Now way of knowing tail duplication will pay off in the future
- Has a cost, could afford it if it pays off

Shu: split (terminology?)

Michael: profile in an interpreter
- Backwards flow analysis, I need this type info?
- I would like this not to be polymorphic
- Would like this to be an int

Shu: tail duplicate until things become monomorphic
- Drives the duplication

Michael: compile without duplication, monitor hot spots

Shu: don't version at some blocks?
- Re-merge if useless?

[DONE] TODO: start sketching out ir/inlining.d
- inlineCall?
- add comments to flesh out process

[DONE] TODO: allocate stacks with malloc, NO_SCAN

[DONE] TODO: use GC.BlkAttr.NO_SCAN when allocating heap, link table

[DONE] FIXME: return with no semicolon causes parse error
- Create failing parser test

Problem: unwinding stack frames on throw or before calls...
- Must setup stack frame as multiple frames before each exiting call?
  - Correct stack height
  - Write return addresses
  - Spill values/types in the proper slots
- Could save on cost of having to spill types too?
- Need to inflate if exiting to interpreter
  - call to interp
  - unsupported behavior
  - unsupported instruction
- Exceptions need to be able to make the caller inflate
  - Probably want a special extern(C) function to inflate/spill stack frames?
  - Map of call instrs to inflate function
- We can still have interpreter entry points in the middle of functions as before!
  - But these will go to non-inlined versions of functions
  - Don't place entry points in the inlined functions, only at top level
  - Not a huge deal
- Functions with inlining can have an internal stack frame size different from numLocals
  - If we optimize an inlined function and remove temps/vars, need to somehow know
    what temps map to which original function temps
    - could use special pseudo-instr to manage this
    - plase pseudo-instr before possible bailout points, function calls

[DONE] TODO: think about dynamic block/version compilation further
- What would the infrastructure look like?
  - Compile to an assembler, write to a code block
  - ol assembler used for interp entry points, interp fallback
- No longer need a queue of things to compile!
  - Blocks, entry points compiled immediately, until branch occurs
- Need an out of line code block
- Contexts need to account for inlining

Dynamic block compilation...
- Could dynamically profile branches/calls on stubs, eventually compile
- Need to manage a code block and append to it
  - Could simply preallocate to start
- Need to keep track of what jumps to what? Only if we need to displace?
- Incremental compilation of functions
- If compiling and branch occurs, create interp fallback stub, install profiling counters
  - First stub to trigger compilation gets concatenated?
  - Could have already compiled multiple loop iterations?
    - No, because you stopped at the branch!
- Inlining, could do it in the backend?
  - Yes, but we need some sort of lazy move, special alloc state
  - Might be able to recompile calls after some counter hits a threshold
- Issues:
  - Suboptimal code, reoptimization more difficult, but not impossible
  - Jumps to movable code, need to place and rewrite jump

Dynamic compilation cons:
- complicates the backend (N level contexts when inlining?)
- possibly reduces optimization opportunities
- hard to reoptimize code
- need to keep around lists of block versions for future compilations
- can't compute total frame size for inlining ahead of time...
  - would need to reserve space ahead of time

Dynamic compilation pros:
- may save compilation time
- get better profiling data
- avoids invalidating on stub hit
- can try going along with an inlining and back out of it?

[DONE] Inlining heuristics:
- max allowable numLocals of the callee
- max allowable number of blocks in the callee
- total caller + callee size
- total caller + callee locals
- IBM paper considers inlining based on profiles at the callee
  - How many callers, how frequently
  - Generates inlining requests for next compilation
  - Works based on call edge density/distribution, relative method hotness

[DONE] TODO: read empirical inlining paper, note insights

[DONE] TODO: look at IR for getPropIdx... Can we benefit from type info at all?
- Has a ton of calls to various methods
- some eq_const, eq_refptr
- Benefit would probably be fairly small, but inlining will help a lot

[DONE] TODO: functions, remove closure caching, slow offset comp path

[DONE] TODO: BOOL_OUT flag on instructions

[DONE] FIXME: v8/splay segfault with JIT
- Does lots of GC, could be related
- Is this fast enough to include in unit tests? Can we make it faster?
- Note: the GC happens increasingly fast! heap space is exhausted

[DONE] TODO: don't init temps to undef, only local variables
- numTemps, numVars?

[DONE] FIXME: i++ does get_global "i" twice???
function () { return i++; }
- confirmed, first value not used
- Problem is we want the value pre-incrementation

[DONE] FIXME: bug with 3d-raytrace
run-time error: undefined base in read of property "intersect"
Scene_prototype_blocked ("programs/sunspider/3d-raytrace.js"@244:27)
- all unit tests pass, make new regress_raytrace test
- iteration index i becomes null
- i is a global variable! some kind of type corruption happening
- problem is with set_global not using type info properly

[DONE] FIXME: type spilling
- Should only write a type when spilling a value AND the type is not in sync
- What if we're writing a dynamic type, e.g.: move
  - Should write 0 value on the word stack
- BUT, what if we have a memory operand?
  - Might still know the type, not write it to the stack...
  - If we're writing a different type and not in sync, write it to the stack?
- Problem: copying types during ret and call is cumbersome
  - getTypeOpnd, pass scratch reg if mem reading is needed?
  - Need to add stack offset param (in case we pushed more stack space!)
  - default is int32_t.max

[DONE] TODO: try to optimize global prop access, remove offset recomputation

[DONE] TODO: make setOutType change type state
- Should result in more versions, but still working code

[DONE] TODO: simple `make install` target

[DONE] TODO: add typeState to CodeGenState

[DONE] TODO: write adversarial GC/JIT test
- Big loop
- Mix many obj refs & integer calculations?
- Branching

[DONE] TODO: improve register spilling, defaultFn, better usage of liveness info

[DONE] TODO: add a V8 benchmark to make test, more sunspider tests?

[DONE] TODO: re-implement return in JIT

[DONE] TODO: usesThis, usesClos, can optimize function calls further

[DONE] TODO: type flags, type state definitions
- Known type bit
  - If not known, it's stored on the stack
- In sync with stack bit
  - if we test a type, the type we now know is what's on the stack
  - if we spill a type tag, stack becomes in sync
  - if we set a type, and it's the same as before, flag unchanged
- 5 bits for type tag itself, if known

[DONE] FIXME: function calls
- Selectively spill non-args in regs before the call
- Everything that's live after the call must be spilled
- Keep non-live flag for spilling?

[DONE] TODO: try eliminating init maps
- Don't store on function, don't use in GC
- Can init less slots if we only worry about uninitialized variables
- Refactor GC to init/reset stack to 0
- Temporarily: when setting a type, write 0 value
  - Writing 0 in get_global prevents GC crash

[DONE] TODO: check if 0 when setting type fixes the GC bug w.r.t. calls/spills
- Crashes during GC

[DONE] TODO: jit/ops.d

[DONE] TODO: default state, only args should be on stack

[DONE] FIXME: jit.d(485): argument is neither in a register nor on the stack
- Problem is with rt_typeof, used in jit/loop_new
- Log the function we're actually compiling
  $1 = set_null
  $3 = eq_refptr $10, $1
  if_true $3 => if_true(A368), if_false(A36B)
$3 is in fact live after eq_refptr
- eq_refptr uses the interp fallback
  - will not map its value as being on the stack!
  - could change interp fallback to fix this?

[DONE] TODO: bitwise-and, must still be missing instrs for lt
- using default for: $7 = lt_i32 $15, $16 ($rt_lt(27EA))

[DONE] TODO: fix set_global
- Bug with type tags? Should get true, get integer 1, integer type tag

[DONE] TODO: implement/fix get_global

[DONE] TODO: pushRegs, popRegs

[DONE] TODO: revise gen_call
- Will test the limits of the reg alloc

[DONE] TODO: implement reg alloc for simple instructions
- add, mul, and
- get_global_obj
- load

[DONE] FIXME: load with refptr gets bus error
- Unaligned memory access or wrong address???
- Could we be, by using int32 offsets, having invalid hi reg values?
  - If so, problematic!
  - There's your problem...

[DONE] FIXME: ; if_true $4 => if_true(32D6), if_false(32E2)
- Jumping to block with wrong reg alloc

[DONE] TODO: exit to interpreter, should spill regs appropriately

[DONE] TODO: revise defaultFn, might need to save allocatable regs

[DONE] TODO: spill logic

[DONE] TODO: make getArgOpnd have a loadVal argument, load to reg
- Assert not bumping output val

[DONE] TODO: make getOutOpnd try to load to reg if not bumping input

[DONE] TODO: make versioning system work without actual versions or reg alloc
- Always the same state, one version

[DONE] TODO: think about block version **state** objects
- State evolves as we go through blocks
- Should be a struct so we can assign it simply
- Need list of block versions, labels with associated states
- For now, ignore type tags, keep them on the stack ***
  - Focus on reg alloc only
- Need a map of blocks to state/label pairs
  - getBlockLabel(block, state)
  - Try to find a match, if none, produce one

[DONE] TODO: integrate level 0 FFI functionality

[DONE] TODO: interference analysis, coloring
- Go over basic blocks, count number of instrs where values interfere
  - Add counts to edges
- Color slots with registers so as to minimize conflicts
  - Use greedy coloring algorithm
  - If register must be used, pick one from neighbor with least contention
- Also color with XMM registers for FP values and spills

[DONE] TODO: JIT-to-JIT call
- fast jit entry points on blocks

[DONE] TODO: liveness analysis for stack slots
- Returns map of instrs to sets of live slots after the instr
- Need to know if we can kill a value after an instr

[DONE] IDEAS: Basic block versioning
- Can version based on spill status, type, known constant value
- Instr flow functions give us type info
- Type checks give us extra type info
- Checking if something is a given constant gives us info
  - e.g.: check type of receiver before inlined call
- Can avoid generating paths that haven't occurred in practice
  - Jumping to non-existing path needs to bailout to interpreter, invalidate function
- Blocks with 0 exec count are stubs
- If IRFunction is transformed for inlining, non-inline paths will have 0 exec count to begin with
- If known constant value, can try generating new version
  - If too many versions already, try to match existing versions more coarsely

[DONE] IDEAS: Versioning JIT
- Generalize versioning to per-version pre-conditions
  - Generic/catch-all version has no conditions required
  - Type requirements of various granularities can be encoded as conditions
- Count interpreter cycles per call to grant versioning/optimization/inlining budget
  - Functions that take long to execute should get more!
- Monitor call args to decide how to version
  - Can specialize all the way down to constants
- Can transform loops into tail calls
  - Optimize the tail

[DONE] TODO: implement callee-guessing
- Map of call instrs to lists of callee fptrs with frequencies
  - Store on the caller function
- Test fptr and not closure ptr

[DONE] TODO: mid-loop entry
- Create entry points for loop headers
- Bitwise and can't be optimized without this

[DONE] TODO: basic block stubbing
- Code should be out of line
- Invalidates code block and all entry points for function
  - Implement through C function
- Run unit tests

[DONE] TODO: implement some of the ops in rt_and
- is_int32, and_i32

[DONE] TODO: make basic method JIT work, use only scratch regs for now, no reg alloc
- Implement jump, if_true
- Implement initial call/ret by bailing out to interp
  - Generate export for continuation target
- Test on bitwise-and to start
- Try unit tests and commit method JIT v0

[DONE] TODO: JIT compilation & entry hooks in interpreter
- If block reaches target exec count, compile its function
- Will automatically work for loops too

[DONE] TODO: secondary entry points for fn returns
- Function to generate the code for an entry point
- Create an exported label? Need to wait until code is assembled to set
- Map of blocks to exported labels
- This code should be out of line ***
- getEntryPoint
- Eliminate initial entry point, just get the entry point for the entry block!

[DONE] ISSUE: you don't know if the caller was running JITted code?
- If calling interpreter function, have to bail out to interpreter first, so that's OK
- If doing JIT-to-JIT call, and then we bail out to the interpreter...
  - KISS: when you do any call, spill the locals

[DONE] TODO: begin compiling basic blocks?
- getBlockLabel?
- stack overflow warning

[DONE] TODO: store CodeBlock pointer on compiled function

[DONE] TODO: solve first problem: how do we enter, how do we bailout
- To enter, call entryFn on some basic block
  - Saves regs, does required prep
- To bailout, pop regs, save wsp, tsp, do return to interpreter
- For now, can have generic bailout label in code gen context

[DONE] TODO: plan register mapping with fixed regs, scratch regs, allocatable regs

[DONE] TODO: read SELF customization article

[DONE] TODO: research procedure cloning, dynamic languages
- Find MATLAB versioning article
  - MaJIC, precompiles version

[DONE] TODO: can we generalize versioning, dispatch based on arbitrary conditions?
- types of class properties involved in parameters (specific type sets)?
  - Is this effective? Avoids invalidation
  - Might have lots of type sets involved?
  - Can disable entry to function with boolean flags, basically
- How granular? can dispatch all the way down to constant values
  - Profiling argument types would make sense here
  - If almost always constant, take advantage
- Heuristic: functions with longer execution time (in interpreter instrs)
  should get more versioning budget/granularity
  - Re-add interpreter cycle counter?
- Should generalize string down to pre-conditions **********
  - Generic/catch-all version has no conditions required ******
  - Type requirements of various granularities can be encoded as conditions
- Start by implementing generic method-based compiler

[DONE] TODO: think about method-based compilation
- Interp fallback
  - Dump stack slots to interp stack
- Mid-loop interp jump
  - Special entry point that jumps into loop (outer loop only?)
  - Can have special prelude code
- Fallback w/ inlining
  - Need to keep track of frames pushed, locals for each frame
  - When inlining, add special call/ret annotation instructions
    - Keeps track of frames pushed, slots added
- Join w/ inlining
  - Join at loop header, not in the middle of inlined calls
- Speculative inlining
  - Can use interp fallback if incorrect guess, or have 2 paths
  - Default path does generic call
- Can prealloc space for inlined frames on call to compiled function
  - When doing inlined call, avoid copying args until write occurs
- Calling non-inlined function
  - Leave extended stack frame as is
  - Put calling instr on stack, as normal
  - Callee checks who caller is when returning, can find actual RA
  - May need to return to interpreter to do call

[DONE] TODO: add support for regexp in parser
var re = /pattern/flags
var re = new RegExp("pattern", "flags");
flags: i, g, m, y

[DONE] TODO: 3d-cube has a horrible trace exit count, why?
- Is it because traces are limited in length? Is it because of recursion?
- MMulti trace has 513 blocks
    root trace entry count: 1160855
    sub-trace entry count : 624093
    trace loop count: 241408
    trace exit count: 919447
- Increasing max trace length doesn't improve things
- getPropIdx isn't the problem
- Low trace count and super long traces doesn't help
- The trace is legitimately very long...

[DONE] TODO: compute trace completion rates?
- increment interp counter on trace start, other counter on final trace completion
- counter for interpreter fallback rate ***
- jit_stats
- Loops? Increment on each trace entry

[DONE] TODO: blog
- Traces, sub-traces
- Stack frame init maps
- Updated perf numbers
- All SunSpider/V8 benchmarks except regexp working, thanks to Tom Low
- FFI
- eval

[DONE] FIXME: segfault on ./higgs programs/sunspider/bitops-bits-in-byte.js 
- Doesn't crash with no JIT
- jump to self at block 30/169 in sub-trace of bits-in-bytes
- Root node has no trace object???? wtf
  - root not marked as a trace start
  - not calling record on it
- not setting root node properly in sub-traces

[DONE] TODO: look at more missing instrs for nsieve-bits
- eq_i8
- does this make sub-traces faster? yes
- crash in sunspider tests, signal 11

[DONE] TODO: review traces and sub-traces, do they make sense?
- long traces probably due to loops in runtime, e.g.: getPropidx
- does allowing longer traces result in slowdowns?
- increasing max trace length makes it slower

[DONE] TODO: jit_dumpinfo

[DONE] TODO: test JIT on earley-boyer
- check memory usage: 2.3%
- sub-traces aren't making much difference

[DONE] TODO: try tweaking trace/sub-trace constants/heuristics
- use jit_nosubs for performance comparisons
- 3d-raytrace is faster with sub-traces
- Tweaking inconclusive, would ideally need automation

[DONE] TODO: jit_disable, jit_dumpasm, jit_nosubs

[DONE] TODO: increment block idx only for trace headers

[DONE] TODO: add/enable more sunspider benchmarks in unit tests

[DONE] FIXME: gc/stackvm crashes with JIT, uses GC
- Crashes during sub-trace compilation

[DONE] FIXME: 3d-raytrace segfaults
- jumps to self too early?

[DONE] FIXME: stack depth issues in sub-traces
- Not keeping track of call stack and call stack depth properly
- Sub-trace needs this initial call stack
- Trace start node needs to start with correct stack depth

[DONE] FIXME: make sub-traces belong to parent trace object, not blocks

[DONE] TODO: make it so sub-traces are part of the root trace tree?
- Do we really need a trace pointer in TraceNode objects, is rootNode ok?

[DONE] TODO: Pass a copy of the CodeGenCtx to the sub-trace?
- Could be a big object
- Can we retrace steps from the root trace? Expensive
  - Expensive but necessary?
  - Could have hundreds of blocks in a main trace
  - Still OK if ctx is relatively small

[DONE] TODO: implement sub traces from if
- If threshold reached
  - call function that begins tracing from block
  - jump to interpreter
- Pass address to patch back for direct jump to trace
  - Write jump directly over a reserved block of nops, 10 + 2 bytes
  - Can reserve 12 bytes, use an assembler to get the proper bytes

[DONE] TODO: Trace node currently stores root node pointer
- Could store trace object pointer instead
- Trace object can store:
  - root trace node
  - parent trace object
  - parent jump address
- Creating the trace object can create the root trace node?

[PASS] TODO: loop to loop, stop at inner trace?
- Doesn't seem to improve performance

[DONE] TODO: keep track of calls/returns during tracing, avoid wasting time?
- Will avoid wasting a lot of time in function traces, super long traces
- Simplifies logic of JIT itself
- Should speedup 3d-cube, 3d-raytrace

[DONE] TODO: better callee-guessing in call

[DONE] TODO: ctx.stopTrace

[DONE] FIXME: 3d-cube, interpreter stack underflow, other crashes
- Caused by trace length being capped? No
- access-binary-trees, multiple levels of recursion in
  run-time error: undefined base in property read
  crash after compiling trace in $rt_getProp(27F5)
- Try disabling global prop access: no
- Disabling ret logic seems to fix it...
- Problem comes from default call/ret implementation not stopping trace

[DONE] FIXME: enable jump to self

[DONE] TODO: remove segment extension code, compile traces from trace nodes

[DONE] FIXME: in nsieve-bits, recording many many traces at rt_not, never compiling

[DONE] TODO: move IIR static ctor to ir/iir.d

[DONE] FIXME: seemingly unrelated blocks in traces...
- Jump into a trace while recording, end up anywhere

[DONE] TODO: implement trace node updating during tracing
- compTrace should take a TraceNode argument, construct the block list
- add a trace node pointer to the interp class?

[DONE] TODO: implement TraceNode class, jit/trace.d
- Node should have count, associated block, depth, tree root, list of children

[DONE] TODO: implement system to constrain trace starts to specific blocks
- Need to label trace start blocks
- Blocks need counter + trace start flag + trace object pointer

[DONE] TODO: refactor global return code into parser
- Useful for eval

[DONE] TODO: implement global eval
- eval_str instruction?

[DONE] TODO: rename segment object to trace, compSegment to compTrace, etc.
- Do grep for Segment/segment, to match comments

[DONE] FIXME: GC bug after multiple runs after load?
- Try to replicate with unit test
  - Hard to achieve, too much code
- rule_loop is the function that was destroyed then called *****
  - appears to be a local function, recreated
  - there are 3 different rule_loop functions...
    - 2 of them transitively added, last one destroyed
- How can we not find one of the rule_loop functions transitively?
- If we GC on global scope... Most functions are destroyed
  - Only a problem if first run occurs first
  - Obviously poor traversal, poor finding of function references
- The problem must be that our transitive function adding is imperfect..
  - Does not implement a proper DFS

[DONE] TODO: ASMComment pseudo-instruction?
- Have function to add comments when dumpasm is enabled?
- Will allow better understanding of asm output

[DONE] TODO: rename JITInstr to ASMInstr

[DONE] TODO: prepare presentation for Friday 15th March
- Explain ideas in more detail
- Elaborate on incremental segment extension
- Is counter=1 like regular tracing?
  - Not exactly, still need multiple passes through segment to extend

[DONE] FIXME: earley-boyer, call to non-function

[DONE] TODO: try self-patching mechanism for optimized global object access?
- cache based on global object address?
- can a load patch its own 32 bit offset???
- flesh out ASM code

[DONE] TODO: IP-relative addressing
- Should be able to specify label, but also extra disp
- Unit asm code execution

[DONE] TODO: refactor instruction operands
- Array of fixed size in instr
- Pointers to subclasses of X86Opnd

[DONE] TODO: IntData JITInstr
- Num bits, value

[DONE] TODO: optimize JIT interp fallback, now have mayGC, isCall
- Test with earley-boyer

[DONE] FIXME: GC during load(), not a proper function call! can't traverse stack
- unit test this, gc/load.js?

[DONE] TODO: remove stack init code from JIT

[DONE] TODO: make interp no longer init stack slots in function calls

[DONE] TODO: refactor GC to use init maps when traversing stack
- Make sure unit tests, earley-boyer still work fine!

[DONE] FIXME: ip is moved before instr is executed...
- Could probably change this with current design

[DONE] TODO: mayGC opcode flag
- Needed by heap_alloc, set_str, set_global, get_global

[DONE] TODO: implement init map system
- bug, seems to be caused by code after branch
- stop adding instrs after branch?

[DONE] FIXME: JIT bug causing segfault in earley-boyer
- Crashes in segment in $rt_class_get_cap(1394), len: 1
- Disabling call and ret JIT instrs does not fix it
- String table gets extended, class gets extended, but no GC yet
    $2 = get_global "$rt_class_ofs_cap", 177
    $1 = get_global_obj
    $3 = call $2, $1, $11 => call_cont(2D5A)
- Could it be get_global? Try disabling?
  - Works without get_global!

[DONE] TODO: optimize set_str

[DONE] TODO: try optimizing/specializing return sequence

[DONE] FIXME: gc causes crash during trace?
- Could the GC be invalidating something?
- Collecting the current function? No
- Segment causing crash is in array_push
  - Loops over $argc
- not crashing in get_arg, set_str, heap_alloc, load
- bug caused by getString in gen_call causing gc!

[DONE] TODO: can we have traces join themselves, e.g.: bitwise-and?

[DONE] TODO: add callStack in CodeGenCtx?
- push/pop the call instructions
- can allow full inlining
- may have problems with very long traces

[DONE] FIXME: v8/crypto sanity check fails

[DONE] TODO: branches extend according to which block is specified in the list
- Last if_true, if no next block is specified, insert counter code
compSegment(Interp, nextBlock, segment = null)
- Segment is created if none exists
- nextBlock gets added to the block list
- compilation loop follows the block list

[DONE] TODO: Create Segment class
- Can store counters, list of blocks, code block, etc.
- Easier to manage!

[DONE] NOTE: block exec counts are betraying us even in very simple cases!
- rt_and, both operands integers
- and_exit and and_sec blocks have the same exec count
- can't tell that the AND condition is always true
- Do we want branch counters instead?
  - Strictly more powerful than block exec counters, can still compute block exec count

[DONE] TODO: log instrs for which default fn is used

[DONE] FIXME: JIT breaks 3d-raytrace?
- Find issue, add jit unit test
- Problem seems to be in the call logic
- String(undefined) produces undefined after compilation
- $rt_isGlobalObj(this) in String starts producing true after compilation

[DONE] TODO: use unique id system for labels, use in toString?
- Just print their current offset?

[DONE] TODO: second assembler object for out of line paths
- Assembler.append(Assembler) function?
- OVF logic => out of line
- Function call interp path => out of line

[DONE] TODO: try logging branch exec counts on if_true
- Log with associated instr
- Many go entirely one way, most unbalanced

[DONE] TODO: refactor all conditional branches to have 2 targets?
- target, excTarget?
- Probably best for block extension
- Need to pick a target to extend the block with either way

[DONE] TODO: blog post about JIT compiler

[DONE] FIXME: v8/earley-boyer requires class extension
- Implement in interp/object.d
- Add unit test for this

[DONE] TODO: try to guess callee function?
- Can introspect a bit, check if calling global fun
- Compare closure pointer against known global
- If known global, run optimized sequence!
- Otherwise run interp version
- Great speedups!

[PASS] TODO: implement CALL instruction
- PROBLEM: call instruction sequence is extremely long!
- Very inefficient to implement

[DONE] TODO: implement RET instruction

[DONE] TODO: stack access functions

[DONE] TODO: table of code gen functions, addressed by opcode
- Default gen function calls the instruction

[DONE] TODO: implement JUMP_TRUE, JUMP_FALSE
- jump to trace end label

[DONE] TODO: implement set_int32
- Need to access wsp, tsp
- Load them from interpreter at start of trace, spill at end?
  - Allows proper indexing
  - Put them in callee-save registers

[DONE] FIXME: including RET or CALL in tracelet causes segfaultl
- Return seems to occur twice?
- Set traceEntry to null before entering trace
- Otherwise, we're setting it to null after trace, undoing work of another trace

[DONE] TODO: command-line option to enable or disable JIT
- options.d?

[DONE] FIXME: somehow, traces make odd behaviors happen, e.g.: call to non-function
- Somehow, semantics differ
- Lots of tracelets seem to get executed successfully
- Setting the IP before instruction execution seems to fix this...

[DONE] FIXME: trace issue, jump(block) can trigger recursive trace exec
- Could jump() set a trace pointer in interp, but not call it?

[DONE] TODO: basic tracelet JIT, jit.d
- Lazily compile tracelets for blocks
- Start with one entry point, as a C function
- Need trace to call into instr op functions
- Trace exits by doing ret

[DONE] TODO: port and test x86 execution tests

[DONE] TODO: convert push/pop test to 64-bit registers

[DONE] TODO: complete porting of assembler tests

[DONE] TODO: begin porting assembler tests

[DONE] TODO: port assembler code

[DONE] TODO: port operand toString

[DONE] TODO: finish porting basics of CodeBlock, add mem block allocation

[DONE] TODO: implement register toString

[DONE] TODO: port operand, encoding code

[DONE] TODO: port instruction table construction

[DONE] TODO: copy over Tachyon assembler tests, instr table

[DONE] TODO: fmod, needed by both raytrace benchmarks

[DONE] FIXME: raytrace sanity check fails
- Problem is division of number by string... assholes.

[DONE] TODO: look at D ABI
- Should match the linux 64-bit C ABI
First six int/pointer arguments in RDI, RSI, RDX, RCX, R8, and R9
Return value is stored in RAX

[DONE] TODO: blog
- Mozilla people, learning, friendly people, pleasant office
- DConf 2013
- Meeting with Apple
- Silicon valley is quite different
- Smartphone
- First pull requests
- Bug fixes
- Feature and benchmark list
- Brainstorming
- Preparing tracelet JIT implementation

[DONE] TODO: Add jump function, to jump to a certain block
- Changes the state of the interpreter, returns
- Asserts target is not null
- add block exec count

[DONE] TODO: enable JSON stdlib module
- parse fails, unknown escape sequence

[DONE] TODO: genCallTargets

[DONE] TODO: make call have 2 targets

[DONE] TODO: make post-call be separate block
- Don't want ret tracelet starting in middle of block
- Better for analysis?
- Alternative is ret stays in same block, IP is post-call
  - Would have to associate tracelet with instr in middle of block!
- bitops-nsieve-bits, before: 19.879, after: 24.189, sep: 21.837

[DONE] FIXME: 4294967295.0 === 0xFFFFFFFF
- Int not represented correctly
- Gen code using set_float instead

[DONE] TODO: Fix toInt32, needed by v8/crypto, v8/splay
- Make it use f64_to_i32
- Add more bitwise unit tests for and, or ops, rsft, ursft
- test corner cases

[DONE] TODO: Comply with ES5 comparison unit test
- Will help certify proper working
- Look at Tachyon implementation of primitives

[DONE] TODO: load_file instr
- Add unit test for this
- Add load to feature list on blog

[DONE] FIXME: deltablue, interpreter stack overflow
- Fails after Error object is finally found?
- Did some assertion fail?

[DONE] TODO: add more basic Tachyon unit tests
- Arith, operators

[DONE] FIXME: do we expect the result of Obj.toString to be a string in $rt_toString

[DONE] FIXME: v8/raytrace, info.color is undefined, shouldn't be
- for-in, used by object extension, is broken
- the presence of "var" screws it up

[DONE] FIXME: v8/deltablue, call to non-function
- EditConstraint corrupts working of UnaryConstraint?
- Setting EditConstraint.prototype.isInput corrupts EditConstraint.prototype.isInput

[DONE] FIXME: typeof global var should produce undefined
- $rt_typeOfGlobal(propName)?
- Needed by v8bench/raytrace
- Implement runtime function to see how practical this is
- Add unit test

[DONE] TODO: parseInt, needed for v8bench/crypto

[DONE] FIXME: interp.interp.RunError: global property "rng_pool" is not defined
- Global var stmt, not initialized to undefined
- Add unit test

[DONE] TODO: add list of working benchmark programs on Higgs page, useful to have

[DONE] TODO: Math.round, needed for 3d-cube

[DONE] FIXME: crypto-md5, crypto-sha1, invalid operand 2 type in op "auto r = x * y;" (int)

[DONE] FIXME: deltablue, 3d-cube, ref ptr out of heap
- Failing on object property
- propIdx is 2, object capacity is 2

[DONE] FIXME: lt,gt,eq functions fails in 3d-raytrace, undefined/null value as input

[DONE] TODO: anon function naming in AST
- Anon functions in sunspider/raytrace.js hard to debug

[DONE] FIXME: v8bench/richards, Segmentation fault
- Can we replicate this in a unit test?

[DONE] TODO: TypeSet, GCRoot, could we just use type monitor objects as weak roots?
- Use linked list kind of system, all type sets linked
- Store associated class, if any
- If class is dead after GC, destroy
- Functions destroy their type sets automatically
- Merge TypeMon and TypeSet

[DONE] TODO: implement delete operator
- Unit test this

[DONE] TODO: complete TypeSet constructor from val, union

[DONE] TODO: complete TypeMon basics

[DONE] TODO: GCRoot assignment operator, copy constructor

[DONE] TODO: blog, higgs interpreter complete
- Flesh out feature list on about page
- Post feature list
- Blog about monitoring
- Mozilla visit

[DONE] TODO: enable stdlib_string unit test, comment out regexp code
- interp.interp.RunError: global property "alloc_str" is not defined

[DONE] FIXME: destroy fun in collectFun causes odd interpreter bug
- Collecting function on stack?
- Log deleted functions

[DONE] TODO: parser, encode operator associativity, improve parenthesization
- Test with Function.toString
- Unit test expressions for correctness
- Problems arise when the parent doesn't have higher priority than us

[DONE] TODO: try to find expression tests that break parser re-parse
- write failing unit test

[DONE] TODO: add problematic expression tests for interpreter

[DONE] TODO: determine how to represent numerical ranges
- Look at moller's paper for insight
- just use int64

[DONE] TODO: start implementing type set object, in D
- interp/type.d?
- operations should mutate set objects? Yes, probably
  - want to keep list of dependencies
  - want to maximize speed of operations

------------------------------------------------------------------------------

Milestone Complete: working benchmarks

[DONE] TODO: for-in loop
- [DONE] Port over Tachyon runtime code for this
- [DONE] Test getPropEnum before implementing loop code gen
- [DONE] Base loop code gen on Tachyon code
  - loop until enum function returns false
- [DONE] Enable for_in unit test

[DONE] TODO: basic Date support
- currentTimeMillis()
- IR instr get_time_ms

[DONE] TODO: class obj, make it a hash table
- like the string table
- add max load consts to layout.py

[DONE] FIXME: string table extension provokes GC
- gc during table ext invalidates string ptr?

[DONE] TODO: arguments object
- If no "arguments" param, create arguments local
- KISS, just create array, copy arg vals in loop, set in local slot
- vars analysis should set usesArguments flag in function
  - KISS for now, any occurrence of "arguments" identifier
- enable gc test

[DONE] TODO: call with apply
- call_apply(closArg, thisArg, argTable, numArgs)
- enable gc test
- add unit Tachyon apply tests

[DONE] TODO: accessing missing global prop should throw exception
- use missing property constant
- assertThrows

[DONE] TODO: missing property constant, like undefined, but not
- [DONE] set_missing
- [DONE] init object properties to missing
- [DONE] revise getProp
- [DONE] revise "in" operator, hasOwnProperty
- [DONE] add unit tests

[DONE] TODO: Look at features of two "real" benchmarks to guide development
- Benchmarks: Bones, sunspider/3d-raytrace
- What features are we missing?
  - Float32Array, could replace by Float64Array, aliased to array
  - Already have everything else for bones!
  - For raytrace, new Date().getTime()
- v8/raytrace uses the for-in loop

[DONE] TODO: string->number, parsing numbers in strings
- stdlib_number unit test

------------------------------------------------------------------------------

Milestone Complete: complete simple interpreter (~Dec 31st)

[DONE] FIXME: topmost function doesn't have closure on stack?
- We free a closure, but can we free all its link indices?
  - No, because the code might still be used...

[DONE] TODO: traverse instructions of dead functions, collect link table refs
- log dead functions

[DONE] TODO: garbage collecting fun refs
- Create new fn ref table
- liveFuns table in interpreter
- When traversing closures, add fns to ref table
- Replace original ref table

[DONE] FIXME: ret addr is calling instruction, not IR function pointer
- Add special instruction pointer type tag

[DONE] TODO: blog post, interpreter milestone complete
- Next goals, monitoring, tracing JIT

[DONE] TODO: edit Higgs page on pgw, add supported features list
- Objects
- Arrays
- Closures
- Variadic functions
- For/while/do loops
- If/switch statements
- UTF-16 strings
- Integer and floating-point arithmetic
- Redefinable arithmetic operators
- Garbage collector

[DONE] TODO: remove GC output during unit tests

[DONE] TODO: garbage collecting string table
- don't forward string table, just re-alloc with same size
- after scan, remove strings table entries without a next pointer
  - need to rebuild table, reinsert strings
  - rebuild from old table
- strcat unit test

[DONE] TODO: remove stack slot init to undef, make it implicit?
- move from push to callFun

[DONE] TODO: make next ptr first field in all layouts
- init next ptr to null
- header is second field
- have GC traverse next pointers in objects

[DONE] TODO: beef up clos alloc test

[DONE] TODO: obj alloc test

[DONE] FIXME: stackvm test, segfault
- allocation completes
- crash after alloc in op_call_new

[DONE] FIXME: deepstack... Stack ref, object not in from-space heap
- collect called manually, not in the middle of anything...
- invalid object is all zeros?
- pointer appears to be from old from-space (zeroed out)
- clearing stack slots on push seems to remove problem
- Temp slots don't get initialized!

[DONE] FIXME: graph test, second collection fails, cannot copy in to-space, heap limit exceeded
- object size is corrupted (by previous GC?)
- happens during op_heap_alloc
- crash during "visiting stack roots"
  - probably, some stack object or stack ref is corrupt
- setting slots to undef on push and pop does not fix the problem
- inserting/removing prints can make the bug disappear...
- layout type of faulty object is closure...
  - object is near boundary of from-space

[DONE] TODO: implement GC count variable, IR instruction

[DONE] TODO: make programs/gc/graph.js run

[DONE] TODO: repeated closure allocation test
- closure in loop
- call closure to test

[DONE] FIXME: heisenbug with repeated closure alloc
- call to non function

[DONE] FIXME: repeated closure allocation produces segfault
- Failure probably occurs during newClos

[DONE] TODO: implement proper shrinkHeap

[DONE] FIXME: heap corruption during collection
- println fails, unhandled type in toString
  - link table problems?

[DONE] TODO: implement heap resizing for GC tests

[DONE] TODO: gc arrays test

[DONE] TODO: while manipulating references in interp, push refs to be saved on stack
- [DONE] setProp 
- [DONE] newObject
  - pay special attention to arguments
- [DONE] interp/string.d
- [DONE] setProp callers
- [DONE] throwError
- [DONE] op_call_new
- [DONE] op_new_clos

[DONE] TODO: eliminate ppClass in newExtObj? How useful is it really?
- Not that important!

[DONE] TODO: store ValuePair in stack root
- Multiple helpful constructors
- Assignment operators

[DONE] TODO: implement stack root system
- use special pointer container object, struct w/ destructor (implement in gc.d)
- object can be linked in doubly linked list

[DONE] TODO: revert to-space alloc code

[DONE] TODO: collect in function test

[DONE] TODO: $ir_gc_collect instruction

[DONE] TODO: get heap size instruction
- $ir_get_heap_size

[DONE] TODO: gcCollect after library loading

[DONE] TODO: gcCollect in middle of library loading

[DONE] TODO: first GC test, call gcCollect after interp init?

[DONE] FIXME: forwarding the same address many times over?

[DONE] TODO: function to allocate to-space
- Check if not allocated in gcCollect, if so allocate

[DONE] TODO: when allocating and running out of space, alloc to-space?
- Can keep allocating in from-space as well!
- Have a special function to check if to-space is allocated, allocate to it

[DONE] TODO: move heapAlloc to interp/gc.d

[DONE] TODO: scan link cells during GC
- Scan as roots

[DONE] TODO: layout_visit_gc(o) dispatching fn

[DONE] TODO: GC obj traversal functions
- Do a get on fields, call gcForward, set the result
  - word/type pairs slightly problematic?
    - if tpField set, call special function to forward

[DONE] TODO: remove array functions from objects.d, maintainability hazard

[DONE] TODO: init object properties and array elements to undefined for now

[DONE] TODO: unit test for obj field init
- Two objects from one class, one with a specific field, one without
  - Second one should come out undefined

[DONE] TODO: word field in object/array/cell should be annoted with type field name
- type field should be resolved

[DONE] TODO: layout_sizeof(o) dispatching fn
- Easy to implement, do this automatically
- obj_get_header(o)

[DONE] TODO: Forwarding pointer in layout
  layout_get_next(o)
  layout_set_next(o, p)
- Set special header flag (top bit), store forwarding pointer after header
- Can write these functions in D if desired

[DONE] TODO: layouts, enforce alignment of fields to field size

[DONE] TODO: implement visitStackRoots

[DONE] TODO: port gcCopy, gcForward

[DONE] TODO: complete port of gcCollect

[DONE] TODO: call gcCollect in heapAlloc function

[DONE] TODO: copy over relevant Tachyon GC code

[DONE] TODO: Make sure pointers are initialized to null
- Unless immediately initialized, init pointers to null

[DONE] TODO: create interp/gc.d

[DONE] TODO: create IRFunction ptr word type tag
- Update in layout.py as well

[DONE] TODO: store ctor class ptr on closure obj?
- refptrs

[DONE] TODO: no more ptr caching in instr/IRFunction, no ptrVal instr arg type

[DONE] TODO: modify opNewClos to use link table entries

[DONE] TODO: use new arr alloc in IR->AST

[DONE] TODO: use new obj alloc in IR->AST

[DONE] TODO: implement newClos in runtime.js
- Issue: need to get IRFunction ptr, add to ref table
  - Special instruction for this?

[DONE] TODO: GET_FUN_PTR
interp.funRefs[cast(void*)fun] = fun;
- GET_FUN_PTR <irfunction>
- Takes ptr, add fn to ref table, produces raw ptr

[DONE] TODO: implement newArr in runtime.js
- Improve Array ctor, use newArr

[DONE] TODO: implement newObj in runtime.js

[DONE] TODO: instructions to access link table
- make_link "name"
- get_link
- set_link

[DONE] TODO: make SET_STR alloc a link table cell internally
- Store cell index in arg
- Add new arg type

[DONE] TODO: add wLinkTable, tLinkTable to interpreter
- Allocate in constructor using malloc
- Have list of free link table entry indices
- Function to get a new link table entry index

[DONE] TODO: create $rt_toNumber
- Used in number constructor

[DONE] FIXME: programs/sunspider/math-spectral-norm.js
interp.interp.RunError: invalid base in property write
- Var statement is parsed incorrectly...
  - Only first identifier is resolved, rest goes in init expression
 - Make a parser unit test

[DONE] FIXME: programs/sunspider/bitops-nsieve-bits.js 
global prop unresolved $rt_not
- Add unit test

[DONE] TODO: float to string support, can't print floats right now!
- expose f64_to_str instruction
- Unit test

[DONE] TODO: can we run more benchmarks? Yes
bitops-nsieve-bits  14.5
math-spectral-norm  3.28
math-partial-sums   10.4
3d-morph            6.07
access-nsieve       8.46
access-fannkuch     33.0

[DONE] TODO: Math.log, Math.exp, Math.pow, Math.ceil, Math.floor, expose as instrs
- Too early to try optimizing this, beat libraries

[DONE] TODO: remove exec flag from heap

[DONE] FIXME: stdlib/math.js, second parse gave different result
    if (term < 1E-15)
        break;
- Add parser unit test, fix

[DONE] TODO: blog post about state of Higgs, features supported, upcoming
- Ask for help, Math.js, anything else?
  - be specific
- Simple JS FFT benchmark?

[DONE] TODO: use exceptions in op_call
- Throw exceptions on error, e.g.: call non-function
- Lookup global exception constructor
  - If avail, create deriv obj from prototype
  - If not avail, throw message string
- Need to run throw logic

[DONE] TODO: catch RunError instances in repl, print stack trace

[DONE] TODO: make stdlib/error.js work

[DONE] TODO: stack trace
- KISS for now, accumulate stack trace in throw

[DONE] TODO: test basic interprocedural try/catch

[DONE] TODO: implement stack unwinding, RunError
- Uncaught exception throws D exception

[DONE] FIXME: infinite loop when generating exc path for runtime calls?
- Infinite loop in compiling finally statements
  - string concat in finally stmt
  - finally stmt has itself in finally list? WRONGE!

[DONE] TODO: exception codegen for call / call_new
- If there is no englobing try/catch and no englobing finally, do nothing special
- If there are englobing finally blocks, need to compile those on exception path
  - After these are compiled, jump to try catch if present, otherwise do interp throw
- Prototype with call

[DONE] TODO: throw from within catch, no catch block, but should trigger finally block
- Could we use getFnlStmts, just use first fnl block?
- make test, finally_throw.js

[DONE] TODO: implement finally support in break/continue
- accumulate finallys until target? can pass list ref as argument to ctx fn
  - compile from inner to outer

[DONE] TODO: implement finally support for return
- find all englobing finally statements
  - compile from inner to outer
- test with finally_ret.js

[DONE] TODO: test intraprocedural throw
- throw_intra.js

[DONE] TODO: basic catch block compilation, ir/ast.d

[DONE] TODO: import some Tachyon stdlib tests (e.g.: boolean)

[DONE] TODO: make String ctor work

[DONE] TODO: make array toString/join work

[DONE] TODO: make new Array(len) work
- Needs arguments object
- unit test
- nqueens test?

[DONE] TODO: make Math.max work

[DONE] TODO: instructions to get arg count, access args

[DONE] TODO: refactor calling convention, call instr will:
  ra, clos, this, argc, args.., ...padding...
- pad with undef for missing args
- push args in reverse order
- push local slots
- ret pops local slots, pops args based on argc, pushes ret val

[DONE] TODO: employ closures to implement Math.random RNG
- Keep the RNG simple, KISS!

[DONE] TODO: use subCtx when creating managing clos cells at function init, save temps

[DONE] TODO: unit test closures more thoroughly
- Tachyon closure tests

[DONE] FIXME: variable resolution
- Currently, after nested function has had its defs added, resolve them
- This seems wrong, need to finish parsing parent functions
- Do a recursive resolveRefs pass at the end?
- Problem: all the scope objects are lost! god damnit.
- Alternative: find all decls at one level before trying to resolve
  - Can just resolve immediately instead of calling resolveRefs

[DONE] TODO: gen code for closure cells
- grab unit tests from Tachyon
- cellMap: maps symbols to closure cells
  - in our case, symbol -> local slot of clos cell
- Creating closure objects, set their cells

[DONE] TODO: allow not having return slot in call instr

[DONE] TODO: resolve captured (closure) vars in parser/vars.d
- In Tachyon, fun.captVars vs fun.escpVars
- captVars: captured from other functions
- escpVars: escaping to nested functions

[DONE] TODO: closure cell layout
- Extra properties after object fields

------------------------------------------------------------------------------

[DONE] TODO: improve valToString

[DONE] TODO: fix AST bracketing (curly braces)?

[DONE] TODO: support for "in" operator

[DONE] TODO: implement instanceof operator (used by stdlib/string)

[DONE] TODO: array prototype object

[DONE] TODO: implement Function.toString()

[DONE] TODO: create fun proto obj in interp?
- Corresponding access instruction

[DONE] TODO: function IR dump, log arg slots

[DONE] TODO: $ir_get_ir_str, $ir_get_ast_str?
- Useful for implementing function toString
- Useful for debugging!

[DONE] TODO: eliminate opSetProp, opGetProp

[DONE] TODO: make ast IR gen use prop access runtime functions

[DONE] TODO: implement getProp, setProp in runtime
- array.length property access
- string indexing access
- Don't need to compute hash code, already computed in strings

[DONE] TODO: implement switch stmt code gen

[DONE] TODO: way to test for null pointer
- Make null constant an actual zero null pointer (refptr)

[DONE] TODO: set_value
- Takes word and type inputs

[DONE] TODO: eq_u8
- Useful for layout type comparison

[DONE] TODO: basic throw instruction support, make it stop interpreter

[DONE] TODO: add global undefined property

[DONE] TODO: interp/objects.d
- Object manipulation primitives
- Keep that code alive

[DONE] TODO: SET_GLOBAL, GET_GLOBAL
- D string argument
- Implement global prop slot caching
- Test speed of bitops-bitwise-and
  - About 10x faster

[DONE] TODO: boolean negation !
- Probably want to inline code sequence?
  - Better compatible with genBoolEval
- Unit test this

[DONE] TODO: finish replacing basic operators with runtime functions
- eg: +=, *=, ...
- Remove corresponding high-level instrs

[DONE] FIXME: genAssign, incompatible with rt fun calls
- Pass delegate function instead

[DONE] TODO: I64/F64 conversion instructions

[DONE] TODO: interp cycle count?
- bitwise-and => 3.72M cycles
- will be less cycles once we have GET_GLOBAL
- currently look through 170+ property names in linear search!

[DONE] TODO: complete bitwise op runtime functions

[DONE] TODO: complete runtime comparison primitives

[DONE] TODO: IIR improvements, eliminate need for $ir_jump_false
- Clearer, more concise!
- genBoolEval? Treat IIR differently

[DONE] TODO: implement/test $rt_toBool
- Before: bitwise and takes 5.97s
- After: bitwise-and takes ~24.6s
- Time probably dwarfed by global lookups

[DONE] TODO: interp file loading
- useful for testing/timing benchmarks

[DONE] TODO: make typeof use runtime function

[DONE] TODO: run controlflow-recursive in unit tests

[DONE] TODO: $rt_eq

[DONE] TODO: assertBool

[DONE] TODO: begin using runtime system for arith ops
- Works for add, make test time seems unaffected

[DONE] FIXME: GC bug redux
- Reference IRFunction in fun table instead of AST
- AST has no pointer to IRFunction

[DONE] TODO: insertRtCall(IRGenCtx ctx, string fName, LocalIdx[] argLocals)
- Current impl uses many IR instrs

[DONE] TODO: JS file tests, import some from Tachyon

[DONE] TODO: comma operator support, ir/ast.d
- Evaluates both expressions, returns second value

[DONE] FIXME: for (var i = 0; i < 1000000; ++i);
    object.Error: heap space exhausted
- SET_STRING allocates string every time

[DONE] FIXME: interpreter crash in unit test
  $rt_toBool('foo')? 1:0
- Crash may or may not happen if source is modified...
- May be related to D GC
  - What if a function we need was randomly collected...?
    - AST or IR collected
- Closure objects keep refs to ASTs
  - Need to keep a function table in interp
- Seems fun.ast has been freed by interp!
    write(core.memory.GC.addrOf(cast(void*)fun.ast));
- Add function reference table in interpreter

[DONE] TODO: Math.pow for integers

[DONE] TODO: $rt_div

[DONE] TODO: $rt_mul

[DONE] TODO: Math.sin, Math.cos, Math.sqrt

[DONE] TODO: cos, sin, sqrt instrs
- Needed for math lib

[DONE] TODO: add interp loadStdLib flag, load stdlib/math.js

[DONE] TODO: $rt_toBool

[DONE] TODO: REPL, don't print if undefined

[DONE] TODO: $ir_print instruction, for debugging
- Use in runtime print function :)

[DONE] TODO: complete $rt_toString

[DONE] TODO: complete $rt_add

[DONE] TODO: complete $rt_strcat

[DONE] TODO: complete $rt_intToStr

[DONE] TODO: GET_STR instruction

[DONE] TODO: heap_alloc instruction
- Unit test w/ load/store

[DONE] TODO: complete low-level arithmetic, bitwise instructions
- Template with mixin

[DONE] TODO: Design Link table
- Part of interpreter, statically allocated, unmoving, contiguous
- primitives to manipulate this (get, set), take a unique id number
- wLinkTable, tLinkTable
- What problem are we trying to solve?
  - For getString: want to link a string object pointer
  - For callNew: want to link a class pointer, different for each callee
  - For newClos, newObj, newArr: want to link a class pointer
    - Two pointers for newClos, closure *and* prototype
  - Want the GC to have easy, fast access to these slots!
- MAKE_LINK instr can give us link cell index (need index, otherwise 2 pointers)
- Want to be able to allocate slots lazily
- JIT may need to link constant objs too. Can be done at compilation time.
- Instrs needing global obj, obj proto?
  - Can have host primitives for this, access through interp object ***
- make_link "classptr", produces index to cell

[DONE] TODO: $rt_typeof
- Will need access to header type field

[DONE] FIXME: obj_get_header not working

[DONE] TODO: Generate runtime functions for layout alloc

[DONE] TODO: Define layout type constants

[DONE] TODO: implement new layout system, layout.py
- Declarative layouts in a list
- add make layout makefile entry
- Generate ASTs from layouts (simple ASTs)
  - For JS, auto add $rt_ prefix to every function name
- Generate D and JS source from ASTs
- layout.d, layout.js

[DONE] TODO: Interp.evalString(string str, string fileName = "string")?
- Use to load layout code

[DONE] TODO: eq_i32, lt_i32

[DONE] TODO: add_i32, mul_i32

[DONE] TODO: load/store instrs
- load_i32, ptr, offs
- simple template for op fun generation

[DONE] TODO: is_refptr, is_const

[DONE] TODO: initial $rt_add runtime function

[DONE] TODO: ftoi instruction, I32_TO_F64

[DONE] TODO: add_i32_ovf, add_f64
- unit test

[DONE] FIXME: branchy IIR, need assignment support

[DONE] TODO: is_int, is_float, is_refptr type test instrs
- Do we ever need to compare type tags? Probably not

[DONE] TODO: implement member call in AST->IR, needed for $rt_toString

[DONE] TODO: test $rt_toString runtime function

[DONE] TODO: branchy IIR syntax: if (%...)

[DONE] TODO: special syntax for inline IR, with % sign (make special unary op?)
- Could just use $iir_ syntax, KISS!
- Normal IIR is a function call expression
- Test in shell

[DONE] TODO: Create extensible table of inlinable IR instructions for IIR access

[DONE] TODO: Create interp/runtime.js file, parse/run this at interp startup

[DONE] TODO: interp.exec(AST), interp.load(file)

[DONE] TODO: integrate SET_ARG into call
- Would make for shorter IR if we call into primitives
- 2 instructions per primitive call could be alot
- constant argument: set_int, then set_arg, kind of retarded!
- setArg is fragile anyways

[DONE] TODO: No more MAX_ARGS for instrs. Var arg system.

[DONE] TODO: Add instruction branch target field
- Refactor branch instructions

[DONE] TODO: Eliminate get_ret and the likes!
- RA is call instr
- Problem: Interp loop sets next instr before call
- Doesn't matter, call/return sets next instr anyways

[DONE] TODO: instr, add IRFunction ptr,
- get rid of raSlot, numLocals in RET, PUSH_FRAME
- Better for supporting exceptions, stack traces!

[DONE] TODO: array unit tests

[DONE] TODO: Modify getProp/putProp
- Look at Tachyon code, port over
- Modify underlying getProp, or higher level?
  - setArrElem assumes array, no toObject
  - go with Tachyon approach, simplify lower level fns

[DONE] TODO: rename confusing len fields in layouts

[DONE] TODO: make type objs in class rawptr, will be host objects

[DONE] TODO: implement opNewArr

[ODNE] TODO: array literal AST->IR

[DONE] TODO: NEW_OBJECT, remove proto local
- Only used for object literals
- stdlib will use custom host functions where needed

[DONE] TODO: array object & array table layout
- Should have array table field for array objects

[DONE] TODO: refactor layout system
- genLayouts
- Auto-generate layout type ids, define constants
- Auto-add type field as first layout field
- Add default field initializers (eg: init next to null)
- Layout extension

[DONE] TODO: alloc min size on closures, proto object
- Test adding many properties to fn.prototype

[DONE] TODO: implement object extension
- Need to handle closures and arrays too!
- Need to define type tags
- Modify getProp to follow next link chain

[DONE] TODO: implement type tags into layout system
- Define as uint32 in layout.d, make enum
- Type should be auto initialized on allocation
- Remove _set_type calls

[DONE] TODO: GET_RET_NEW
- ISSUE: need access to the this object passed to the call!
- Push a hidden this argument on the stack?
- Could have CALL_NEW produce this object in output slot, do explicit
  coupling between CALL_NEW and GET_RET_NEW?
  - Seems reasonable?
- Unit tests for new operator

[DONE] TODO: fix this binding resolution

[DONE] TODO: do proto lookup in opCallNew

[DONE] TODO: prototype chain support in lookup
- Test that missing props evaluate to false

[DONE] TODO: simplify class system, allocate proto slot, all property slots for now!

[DONE] TODO: create proper closure in opNewClos, fix opCall
- Test properties on function objects

[DONE] TODO: closure layout
- Needed for functions to have .prototype
- Cannot concat new props on prop array at compile time...
- Want list of closure cell pointers, function pointer

[DONE] TODO: opNew, AST->IR for new

[DONE] TODO: FP less-than comparison

[DONE] TODO: basic floating-point support
- assertFloat w/ epsilon

[DONE] TODO: Interp.getSlot/Interp.setSlot with ValuePair
- Use to simplify code in interp/ops.d

[DONE] TODO: object literal support w/ unit tests

[DONE] TODO: opSetProp

[DONE] TODO: implement opNewObj
- Lazily create new object class?

[DONE] TODO: make alloc set size fields automatically

[DONE] TODO: auto-generate alloc layout method taking interp as parameter

[DONE] TODO: AST->IR for indexed operations, property access

[DONE] TODO: object literal AST->IR

[DONE] TODO: typeof operator
- IR, AST->IR

[DONE] TODO: string concatenation

[DONE] TODO: Implement getString, replace uses of makeString by getString

[DONE] TODO: string table extension

[DONE] TODO: Interpreter method to get a string from the table

[DONE] TODO: alloc initial string table
- allocStrTable(Interp*)

[DONE] TODO: string hash code computation

[DONE] TODO: string table layout
- len
- num_strs

[DONE] TODO: interp/string.d

[DONE] TODO: interp/ops.d

[DONE] FIXME: many moves are unnecessary
- Moving a value into the output slot, just to transfer the value
- Possible fix: add setOutSlot again

[DONE] TODO: ability to prescribe output slot to sub-context

[DONE] TODO: test unary plus, minus operators

[DONE] TODO: in-place operators, +=, -=, etc.
- Issue: "a[f()] += 1" is not "a[f()] = a[f()] + 1"
  - Don't want to evaluate f twice
- TODO: check in what order V8 evaluates lhs, rhs?
  - lhs, then rhs
- Try passing IR instr to assgToIR for in-place operators

[DONE] TODO: revise ast-to-ir design, currently hard to debug&maintain
- context/sub-contexts interfere with each other in unpredictable way
- out slot should be allocated in current context too, to avoid collision
- should eliminate desired out slot/set out slot mechanism?
  - inserts confusing invisible moves!
  - every expression allocates an output temp for itself
- favor simpler, more robust design!
- When creating sub-ctx, decide if it has output or not
  - If it has output, allocate out slot immediately

[DONE] TODO: fix class desc, prop idx instead of woffs/toffs

[DONE] TODO: test global function declarations

[DONE] TODO: test global var statement

[DONE] TODO: global var unit tests

[DONE] TODO: basic SET_GLOBAL, GET_GLOBAL interp implementation

[DONE] TODO: SET_GLOBAL, GET_GLOBAL IR instructions + IR gen
- opSetGlobal, opGetGlobal?

[DONE] TODO: allocate global object in interpreter init function
- Also need to allocate global class
- Also need to initialize both objects
- Make room for 512 properties

[DONE] TODO: finalize initial object layout, class desc layout
- Start with simple layouts
  - V8 uses at least 3 extra words per object, if not more!

Objects have:
- Header
- Num fields
- Class ptr
- Next ptr
- Prop words
- Prop types
- Proto is property 0

Arrays are objects with special properties:
- array table
- length, capacity

Functions are objects with special properties:
- fn ptr slot (raw ptr)
- fixed number of closure vars (can be named)

Class desc:
- Needs next pointer too, so we can add new fields if needed

[DONE] TODO: IR gen for logical and, logical or
- More unit tests

[DONE] TODO: implement/test string concat

[DONE] TODO: implement SET_STR in interpreter
- Lazily allocate strings in the interpreter?
- Unit test this

[DONE] TODO: instr implementation functions
- instr type objects, rename to opcode
- Have pointer to implementation function
  - implementation takes interp state pointer as input

[DONE] TODO: merge Interp and State, no need for two classes

[DONE] FIXME: crash bug, taking address of function wrong

[DONE] TODO: implement string constant IR gen

[DONE] TODO: think about object layout/format further
- Object needs next ptr, otherwise can't reallocate more space
  - Only needed when writing past num fields
- Simple approach might be best!

[DONE] ISSUE: reading field from object, always need to check next pointer...
- Never know that object is big enough to have this field
- Unless class has special "all conforming" field?
  - All pointers to old objects eliminated during GC
- Result: as soon as a new field is added to one object, class is expanded, 
  not all conform (unless only one object of this type), any JITted using this
  class code must be recompiled not to assume next is null
- Global object: if preallocated large, can stay conforming

[DONE] TODO: SET_STR instruction
- Have string + ref/ptr val, not yet allocated?
- Note: string references exist outside the heap

[DONE] TODO: rename REF to REFPTR

[DONE] TODO: interp/layout.js
- genLayout(), test with mixin immediately, print output

[DONE] TODO: heap memory block
    import core.sys.posix.unistd, core.sys.posix.sys.mman;
    PROT_READ | PROT_WRITE | PROT_EXEC;
    auto mem = mmap(null, length, flags, MAP_PRIVATE | MAP_ANON, -1, 0);
    if (mem == MAP_FAILED)
        return null;
    return cast(ubyte*)mem;
- Must be executable ***
- State should allocate a ubyte array for the heap. Must be immovable.
- Alloc ptr is bumped and aligned (see previous gc code)

[DONE] TODO: break, continue IR gen
- When entering IR gen for a loop, associate labels with break, continue blocks
  in the current context.
- Make a context function for this, pass a statement, the break and continue blocks
- Make a context function to do a recursive break or continue target lookup

[DONE] TODO: break, continue with and without label in parser

[DONE] TODO: label support in parser
    LabelledStatement :
        Identifier : Statement
- Store a list of labels on the statement
- Try with backtracking, see how speed is affected

[DONE] TODO: IR gen for cond ? expr

[DONE] TODO: IR gen for post incr., decr

[DONE] TODO: IR gen for do-while loop

[DONE] TODO: IR gen for for loop

[DONE] TODO: Interpreter while loop test

[DONE] TODO: repl, if ExprStmt, transform into ReturnStmt?

[DONE] TODO: repl, output to string?

[DONE]FIXME: handle incorrect argument counts, currently crashes
- add unit tests

[DONE] TODO: state.move function

[DONE] FIXME: IR function args printing

[DONE] TODO: test fib

[DONE] TODO: test fact?

[DONE] TODO: ValuePair to string

[DONE] TODO: test lt comparison

[DONE] TODO: test branching

[DONE] TODO: implement JUMP, JUMP_TRUE, SET_TRUE, BOOL_VAL instructions

[DONE] TODO: implement CMP_LT comparison instruction

[DONE] TODO: test local var assignment

[DONE] TODO: parameter passing

[DONE] TODO: function calls, return global call
- unit tests

[DONE] TODO: unit tests for global expr return

[DONE] TODO: basic interpreter loop
- Capable of evaluating global expr

[DONE] TODO: calling of top unit-level functions in interpreter
- Interp.run(ASTProgram) ?
- Interp.getRet() ?

[DONE] TODO: PUSH_FRAME call at start of function

[DONE] TODO: start implementing simple interpreter
- Could cheat, closures as IR fn ptrs
- Interpreter state structure
  - Double stack system, two base pointers, two top pointers
  - IR instruction pointer
  - heap allocPtr?

[DONE] TODO: auto name unit functions
- use delegate, map?

[DONE] TODO: reverse local indices after IR gen?
- Issue: want to use stack pointer, not base pointer
- Need to know how many locals there are
- Highest local becomes index 0, top of stack

[DONE] TODO: IR gen, map hidden args in local map

[DONE] TODO: IR gen for closures of nested functions

[DONE] TODO: use IR function in new_clos IR

[DONE] TODO: look at IR for global call

[DONE] TODO: IR gen for function call

[DONE] TODO: IR gen for function expressions

[DONE] Call protocol ISSUES:
- Many hidden args (closure, this, nArgs, RA)
- Should we push all after normal args? Practical, may be problematic if frame resizing needed
  - Not a problem for the JIT if call is inlined (most calls can be?)
  - Not a problem if no resizing!
- Would want call instr to take exception block arg?
  - Technically, this can be some annotation per return address for a function!

Stack frame layout (grows down):
        arg0
        arg1
...
        argN
        closure (pushed by call)
        this    (pushed by call)
        nArgs   (pushed by call)
        RA      (pushed by call as raw pointer)
...
SP+2    local
SP+1    tmp
SP+0    tmp

[DONE] TODO: IR instructions for call protocol

[DONE] FIXME: resolve vars in assign lhs exprs?

[DONE] TODO: pretty print of expressions with less parentheses
- Can parenthesize sub-expressions
- When do we need parentheses?
  - Parent has higher precedence: (x + y) * z
- getPrec function, returns highest by default (atomic)

[DONE] TODO: IR gen for while statement

[DONE] TODO: float expr

[DONE] TODO: IndexExpr, merge with dot operator to simplify AST
- create string expr from ident

[DONE] TODO: IR gen for VarStmt

[DONE] TODO: code gen for if statement

[DONE] TODO: IR for undef constant, return undef by default

[DONE] TODO: decide on IR generation strategy.
- Current code generation strategy:
  - Create codegen context for sub-expressions
  - Can specify an output slot (where the sub-expression should store its output)
  - Sub-expression can specify it already has a slot, move inserted if needed
  - Sub-expression can get a slot allocated for its output if none was specified
- What is problematic about this approach? How can we fix it?
  - Need more higher-level constructs, simplifications for common operations

[DONE] TODO: unary negation code gen

[DONE] TODO: look at Marc's simple C compiler. It uses a stack machine.

[DONE] TODO: for-in statement parsing
- need to make work with regular for statement
- if there's no var, we know it's an expression
- could parse whole expression, see if it's an "in" expression ***?
- if starts with var, parse following expression
  - check if expr is "in" expression
  - can't parse as real var statement...
- for var ... in, could try peeking ahead more

[DONE] TODO: peekSep, peekKw

[PASS] TODO: IR, fuse compare and jump
- Uselessly complicates IR->AST translation

[DONE] TODO: optional catch clause

[DONE] TODO: try parsing stdlib

[DONE] TODO: fix sunspider/3d-raytrace parsing/toString bug

[DONE] TODO: decide on boxing scheme
- Scraping float bits for tagging is problematic
- x86 has (all valid in 64-bit):
    CMP r/m8, imm8 : two-byte instruction
    MOV r/m8, imm8 : two-byte instruction
    MOV r8,r/m8     : 2 bytes?
    MOV r/m8,r8     : 2 bytes?
- With double wrappers, don't need to query objects about their type!
- ASM microbenchmark?
  - Performance indistinguishable between one vs two stack
    pointers, separate type array or not
- "Representing Type Information in Dynamically Typed Languages"
  - Had mostly good things to say
  - Seemed to assume that the only "large-wrapper" option is two words
- Separate tags may have advantages for instr level parallelism (ILP)

[DONE] TODO: adapt parser code
- [DONE] fix operator precedence, operator table
- [DONE] new operator
- [DONE] function syntax, missing fn name
- [DONE] object literal syntax
- [DONE] string literals with single quotes
- [DONE] source should be processed as wstring, UTF-16
- [DONE] string expr should store wstring
- [DONE] hex/unicode string escapes
- [DONE] hex number support
- [DONE] variables, one scope per function
- [DONE] functions, find fn decls in scope
- [DONE] variables, multiple decls per statement
- [DONE] optional semicolon for expression statements
- [DONE] test empty statement
- [DONE] multiline string continuation
- [DONE] re-parse test
- [DONE] optional semicolon for var statement
- [DONE] optional semicolon for return and throw
- [DONE] fix bug with crypto benchmark, do diff
- [DONE] break, continue statements
- [DONE] switch statement, as if cascade
- [DONE] more unit tests
- [DONE] real JS code unit tests, sunspider benchmarks
- [DONE] reverse operator precedence numbering
- [DONE] implement comma operator

[DONE] TODO: put project on github

[DONE] TODO: create Higgs project folder, move code

[DONE] TODO: how many benchmarks can we run with this? Need 2-5 (easier first)
- access-binary-trees, new operator
- math-spectral-norm, uses FP
- math-cordic, uses FP
- access-fannkuc, uses arrays
- access-nbody, uses FP math, arrays
- navier-stokes, uses arrays, FP math
- string-base64, uses strings, arrays
- crypto-*, strings, arrays
- crypto (V8), strings, arrays, math, new
- richards
- splay
- deltablue, uses .call
- raytrace, uses .apply, arguments as object, object literals, FP math
- earley-boyer, uses .call, .apply, arrays, strings
- some of the new octane ones might be feasible (non-DOM ones)

